<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self' wss://pocket-agent-chat-production.up.railway.app https://pocket-agent-chat-production.up.railway.app https://cdn.jsdelivr.net;">
  <title>Pocket Agent</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0a0b;
      --bg-secondary: #141415;
      --bg-tertiary: #1c1c1e;
      --border: #2a2a2d;
      --text-primary: #fafafa;
      --text-secondary: #a1a1a6;
      --text-muted: #636366;
      --accent: #a855f7;
      --accent-secondary: #ec4899;
      --accent-hover: #c084fc;
      --user-bubble: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
      --user-bubble-solid: #a855f7;
      --assistant-bubble: #1c1c1e;
      --error: #ef4444;
      --success: #22c55e;
      --radius: 20px;
      --radius-sm: 10px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Sora', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      position: relative;
    }

    /* Session Tabs */
    .tabs-container {
      display: flex;
      align-items: center;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      gap: 4px;
      overflow-x: auto;
      flex-shrink: 0;
    }

    .tabs-container::-webkit-scrollbar {
      height: 0;
    }

    .tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-bottom: none;
      color: var(--text-secondary);
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 12px;
      font-weight: 400;
      cursor: grab;
      border-radius: 8px 8px 0 0;
      transition: background 0.15s ease, color 0.15s ease, transform 0.15s ease, opacity 0.15s ease, border-color 0.15s ease;
      white-space: nowrap;
      max-width: 180px;
      position: relative;
      user-select: none;
      margin-bottom: -1px;
    }

    .tab:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
      border-color: var(--text-muted);
    }

    .tab.active {
      color: var(--text-primary);
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-bottom: 1px solid var(--bg-primary);
    }

    .tab.dragging {
      opacity: 0.6;
      cursor: grabbing;
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .tab.dragging .tab-close {
      color: rgba(255,255,255,0.7);
    }

    .tab.loading .tab-name {
      background: linear-gradient(
        90deg,
        var(--text-primary) 0%,
        var(--text-primary) 40%,
        #60a5fa 50%,
        var(--text-primary) 60%,
        var(--text-primary) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tab-text-shimmer 1.5s ease-in-out infinite;
    }

    @keyframes tab-text-shimmer {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    .tab-name {
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .tab-name-input {
      background: transparent;
      border: 1px solid var(--accent);
      border-radius: 4px;
      color: var(--text-primary);
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 12px;
      font-weight: 400;
      padding: 2px 6px;
      width: 100px;
      outline: none;
    }

    .tab-close {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      line-height: 1;
      font-size: 14px;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .tab-close:hover {
      background: var(--error);
      color: white;
    }

    .tab-telegram-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0088cc;
      flex-shrink: 0;
      margin-left: 2px;
    }

    .tab-telegram-icon svg {
      width: 12px;
      height: 12px;
    }

    .new-tab-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      background: transparent;
      border: 1px dashed var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      transition: all 0.15s ease;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .new-tab-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header-logo {
      width: 20px;
      height: 20px;
      object-fit: contain;
      filter: invert(1) brightness(2);
      image-rendering: -webkit-optimize-contrast;
    }

    header h1 {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      margin: 0;
    }

    .version-badge {
      font-family: 'Sora', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 6px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
    }

    .model-badge {
      font-family: 'Sora', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      padding: 2px 20px 2px 8px;
      border-radius: 4px;
      margin-left: 8px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
      border: none;
      outline: none;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath fill='%23ffffff' d='M0 0l4 5 4-5z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      transition: opacity 0.15s ease;
    }

    .model-badge:hover {
      opacity: 0.85;
    }

    .model-badge option {
      background: #1a1a2e;
      color: #ffffff;
      font-size: 12px;
    }

    .update-badge {
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      padding: 2px 8px;
      border-radius: 4px;
      margin-left: 8px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
      cursor: pointer;
      display: none;
      animation: pulse-update 2s ease-in-out infinite;
    }

    .update-badge:hover {
      background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
    }

    @keyframes pulse-update {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .stats {
      font-size: 10px;
      color: var(--text-muted);
      font-weight: 500;
      line-height: 1;
    }

    /* Hamburger Menu */
    .hamburger-menu {
      position: relative;
    }

    .hamburger-btn {
      width: 28px;
      height: 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .hamburger-btn:hover {
      background: var(--border);
      transform: scale(1.05);
    }

    .hamburger-btn span {
      display: block;
      width: 14px;
      height: 2px;
      background: var(--text-secondary);
      border-radius: 1px;
      transition: all 0.2s ease;
    }

    .hamburger-btn:hover span {
      background: var(--text-primary);
    }

    .hamburger-btn.active span:nth-child(1) {
      transform: rotate(45deg) translate(4px, 4px);
    }

    .hamburger-btn.active span:nth-child(2) {
      opacity: 0;
    }

    .hamburger-btn.active span:nth-child(3) {
      transform: rotate(-45deg) translate(4px, -4px);
    }

    .menu-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 180px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 200;
      overflow: hidden;
    }

    .menu-dropdown.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: transparent;
      border: none;
      width: 100%;
      text-align: left;
      color: var(--text-secondary);
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .menu-item:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .menu-item svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .menu-item.danger:hover {
      color: var(--error);
    }

    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* About Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.show { display: flex; }

    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      width: 90%;
      max-width: 360px;
      overflow: hidden;
      animation: modalIn 0.2s ease;
    }

    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.96); }
      to { opacity: 1; transform: scale(1); }
    }

    .modal-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--bg-secondary);
    }

    .modal-icon {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }

    .modal-icon.pixel-cat {
      width: 28px;
      height: 20px;
      background: transparent;
      border: none;
      position: relative;
    }

    .modal-icon.pixel-cat::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 3px;
      top: 0;
      left: 0;
      animation: pixelcat 0.6s steps(1) infinite;
      image-rendering: pixelated;
    }

    .modal-title h2 {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 15px;
      font-weight: 700;
      margin: 0;
    }

    .modal-title p {
      font-size: 11px;
      color: var(--text-muted);
      margin: 2px 0 0;
    }

    .modal-close {
      margin-left: auto;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover { color: var(--text-primary); }

    .modal-body {
      padding: 16px;
    }

    .about-content {
      color: var(--text-secondary);
      font-size: 13px;
      line-height: 1.6;
    }

    .about-content p {
      margin: 0 0 12px;
    }

    .about-content p:last-child {
      margin-bottom: 0;
    }

    .about-links {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
    }

    .about-link {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      text-decoration: none;
      font-size: 13px;
      transition: all 0.15s;
      cursor: pointer;
    }

    .about-link:hover {
      border-color: var(--accent);
      background: rgba(255, 136, 0, 0.1);
    }

    .about-link svg {
      width: 18px;
      height: 18px;
      color: var(--accent);
      flex-shrink: 0;
    }

    .about-link span {
      flex: 1;
    }

    .about-link small {
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Messages Container */
    #messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      scroll-behavior: smooth;
    }

    #messages::-webkit-scrollbar {
      width: 6px;
    }

    #messages::-webkit-scrollbar-track {
      background: transparent;
    }

    #messages::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    #messages::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* Scroll Buttons */
    .scroll-btn {
      position: fixed;
      right: 24px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      z-index: 100;
    }

    .scroll-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .scroll-btn.visible {
      opacity: 1;
      visibility: visible;
    }

    .scroll-btn svg {
      width: 18px;
      height: 18px;
    }

    #scroll-top-btn {
      top: 100px;
    }

    #scroll-bottom-btn {
      bottom: 140px;
    }

    #gchat-scroll-top-btn {
      top: 100px;
    }

    #gchat-scroll-bottom-btn {
      bottom: 140px;
    }

    /* Message Bubbles */
    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: var(--radius);
      line-height: 1.5;
      font-size: 14px;
      word-wrap: break-word;
      animation: messageIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      transform-origin: bottom;
    }

    @keyframes messageIn {
      0% {
        opacity: 0;
        transform: translateY(16px) scale(0.92);
      }
      50% {
        transform: translateY(-4px) scale(1.02);
      }
      75% {
        transform: translateY(2px) scale(0.99);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .message.user {
      align-self: flex-end;
      background: var(--user-bubble);
      color: white;
      border-bottom-right-radius: 6px;
      box-shadow: 0 4px 14px rgba(168, 85, 247, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .message.user:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.35);
    }

    .message.assistant {
      align-self: flex-start;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-bottom-left-radius: 6px;
      color: var(--text-primary);
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .message.assistant:hover {
      transform: translateY(-1px);
      border-color: var(--text-muted);
    }

    .message.system {
      align-self: center;
      background: transparent;
      color: var(--text-muted);
      font-size: 13px;
      padding: 8px 16px;
    }

    .telegram-header {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #0088cc;
      margin-bottom: 6px;
      font-weight: 500;
      opacity: 0.9;
    }

    .telegram-header svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .message.error {
      background: rgba(239, 68, 68, 0.06);
      border: 1px solid rgba(239, 68, 68, 0.2);
      color: var(--text-primary);
    }

    .message.error .error-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--error);
      margin-bottom: 4px;
    }

    .message.error .error-body {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.5;
    }

    .message.error .error-code {
      display: inline;
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    }

    .message.error .error-report {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
      font-style: italic;
    }

    /* Queued message state - greyed out until processing */
    .message.queued {
      opacity: 0.5;
      filter: grayscale(30%);
      transition: opacity 0.3s ease, filter 0.3s ease;
    }

    .message.queued::after {
      content: 'queued';
      position: absolute;
      top: -8px;
      right: 8px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #ffffff;
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message.user.queued {
      position: relative;
      box-shadow: none;
    }

    .message.user.queued:hover {
      transform: none;
      box-shadow: none;
    }

    /* Scheduled task badge */
    .message.scheduled {
      position: relative;
    }

    .message.scheduled::after {
      content: attr(data-badge);
      position: absolute;
      top: -8px;
      left: 8px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #ffffff;
      background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Telegram message badge */
    .message.from-telegram {
      position: relative;
    }

    .message.from-telegram .telegram-badge {
      position: absolute;
      top: -8px;
      right: 8px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #ffffff;
      background: linear-gradient(135deg, #229ED9 0%, #1a7fb3 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message.from-telegram .telegram-badge svg {
      width: 10px;
      height: 10px;
      fill: #ffffff;
    }

    /* iOS message badge */
    .message.from-ios {
      position: relative;
    }

    .message.from-ios .ios-badge {
      position: absolute;
      top: -8px;
      right: 8px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      color: #ffffff;
      background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message.from-ios .ios-badge svg {
      width: 10px;
      height: 10px;
      fill: #ffffff;
    }

    /* Workflow badge */
    .message.from-workflow {
      position: relative;
    }

    .message.from-workflow::after {
      content: 'workflow';
      position: absolute;
      top: -8px;
      left: 8px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #ffffff;
      background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Queue indicator in status */
    .queue-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      margin-top: 4px;
    }

    .queue-indicator .queue-count {
      background: var(--accent);
      color: white;
      padding: 1px 6px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 10px;
    }

    /* Code blocks in messages */
    .message code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 13px;
    }

    .message pre {
      background: rgba(0, 0, 0, 0.4);
      padding: 12px;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      margin: 8px 0;
    }

    .message pre code {
      background: none;
      padding: 0;
    }

    /* Markdown elements - tight spacing for chat */
    .message h1, .message h2, .message h3, .message h4 {
      margin: 1em 0 0.4em 0;
      font-weight: 600;
      line-height: 1.3;
    }

    .message h1:first-child, .message h2:first-child,
    .message h3:first-child, .message h4:first-child {
      margin-top: 0;
    }

    .message h1 { font-size: 1.2em; }
    .message h2 { font-size: 1.1em; }
    .message h3 { font-size: 1.05em; }
    .message h4 { font-size: 1em; }

    .message p {
      margin: 0;
    }

    .message p + p {
      margin-top: 0.5em;
    }

    .message > *:last-child {
      margin-bottom: 0 !important;
    }

    .message > *:first-child {
      margin-top: 0 !important;
    }

    .message ul, .message ol {
      margin: 0.3em 0;
      padding-left: 1.4em;
    }

    .message ul:first-child, .message ol:first-child { margin-top: 0; }
    .message ul:last-child, .message ol:last-child { margin-bottom: 0; }

    .message li {
      margin: 0;
      padding: 0;
      line-height: 1.5;
    }

    .message li + li {
      margin-top: 0.1em;
    }

    .message li p,
    .message li > p,
    .message li p:first-child,
    .message li p:last-child {
      margin: 0;
      padding: 0;
      display: inline;
    }

    .message a {
      color: #60a5fa;
      text-decoration: underline;
      text-decoration-color: rgba(96, 165, 250, 0.4);
      text-underline-offset: 2px;
    }

    .message a:hover {
      color: #93c5fd;
      text-decoration-color: rgba(147, 197, 253, 0.6);
    }

    .message.user a {
      color: #bfdbfe;
      text-decoration-color: rgba(191, 219, 254, 0.4);
    }

    .message.user a:hover {
      color: #ffffff;
      text-decoration-color: rgba(255, 255, 255, 0.6);
    }

    .message hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 0.6em 0;
    }

    .message blockquote {
      border-left: 3px solid var(--accent);
      padding-left: 0.8em;
      margin: 0.4em 0;
      color: var(--text-secondary);
    }

    .message .table-wrapper {
      overflow-x: auto;
      margin: 0.5em 0;
      max-width: 100%;
    }

    .message table {
      border-collapse: collapse;
      min-width: 100%;
      font-size: 0.95em;
      white-space: nowrap;
    }

    .message th, .message td {
      border: 1px solid var(--border);
      padding: 0.4em 0.6em;
      text-align: left;
    }

    .message th {
      background: var(--bg-tertiary);
    }

    .message strong { font-weight: 600; }
    .message em { font-style: italic; }

    /* Status Indicator */
    .status-indicator {
      align-self: flex-start;
      padding: 12px 16px;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      border-bottom-left-radius: 6px;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: messageIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      max-width: 80%;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
    }

    .status-spinner {
      width: 24px;
      height: 18px;
      background: transparent;
      flex-shrink: 0;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .status-spinner::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 3px;
      top: 0;
      left: 0;
      animation: pixelcat 0.6s steps(1) infinite;
      image-rendering: pixelated;
    }

    @keyframes pixelcat {
      /* Frame 1: Cat walking - legs apart */
      0%, 25% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail up */
          18px 6px 0 var(--accent), 21px 3px 0 var(--accent),
          /* Legs - apart */
          3px 15px 0 var(--accent), 12px 15px 0 var(--accent);
      }
      /* Frame 2: Cat walking - legs together */
      25.01%, 50% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail middle */
          18px 9px 0 var(--accent), 21px 6px 0 var(--accent),
          /* Legs - together */
          6px 15px 0 var(--accent), 9px 15px 0 var(--accent);
      }
      /* Frame 3: Cat walking - legs crossed */
      50.01%, 75% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail down */
          18px 12px 0 var(--accent), 21px 9px 0 var(--accent),
          /* Legs - reversed */
          12px 15px 0 var(--accent), 3px 15px 0 var(--accent);
      }
      /* Frame 4: Cat walking - legs wide */
      75.01%, 100% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail up */
          18px 6px 0 var(--accent), 21px 3px 0 var(--accent),
          /* Legs - wide */
          0 15px 0 var(--accent), 15px 15px 0 var(--accent);
      }
    }

    .status-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .status-preview {
      font-size: 11px;
      font-style: italic;
      color: var(--text-secondary, #888);
      max-height: 32px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: none;
      opacity: 0.7;
    }

    .status-action {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 13px;
      font-weight: 400;
      background: linear-gradient(
        90deg,
        var(--text-primary) 0%,
        var(--accent) 20%,
        var(--accent-secondary) 40%,
        var(--accent) 60%,
        var(--text-primary) 80%,
        var(--accent) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 2s ease-in-out infinite;
    }

    @keyframes shimmer {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    /* Subagent active state - purple/pink vibe */
    .status-indicator.subagent-active {
      border-color: #a855f7;
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(236, 72, 153, 0.1) 100%);
    }

    .status-indicator.subagent-active .status-spinner {
      /* Pixel cat already uses --accent which is purple */
    }

    .status-indicator.subagent-active .status-action {
      background: linear-gradient(
        90deg,
        #a855f7 0%,
        #ec4899 25%,
        #a855f7 50%,
        #ec4899 75%,
        #a855f7 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1.5s ease-in-out infinite;
    }

    /* Tool blocked state - red/orange warning vibe */
    .status-indicator.tool-blocked {
      border-color: #ef4444;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(249, 115, 22, 0.15) 100%);
      animation: blocked-pulse 0.5s ease-in-out 2;
    }

    .status-indicator.tool-blocked .status-action {
      background: linear-gradient(
        90deg,
        #ef4444 0%,
        #f97316 50%,
        #ef4444 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1s ease-in-out infinite;
    }

    .status-indicator.tool-blocked .status-detail {
      color: #f97316;
    }

    @keyframes blocked-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    /* Pocket CLI active state - green/cyan vibe */
    .status-indicator.pocket-cli-active {
      border-color: #22c55e;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(103, 232, 249, 0.1) 100%);
    }

    .status-indicator.pocket-cli-active .status-action {
      background: linear-gradient(
        90deg,
        #22c55e 0%,
        #67e8f9 25%,
        #22c55e 50%,
        #67e8f9 75%,
        #22c55e 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1.5s ease-in-out infinite;
    }

    .status-indicator.pocket-cli-active .status-detail {
      color: #22c55e;
    }

    /* Agent Teams active state - blue/cyan vibe */
    .status-indicator.team-active {
      border-color: #3b82f6;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
    }

    .status-indicator.team-active .status-action {
      background: linear-gradient(
        90deg,
        #3b82f6 0%,
        #06b6d4 25%,
        #3b82f6 50%,
        #06b6d4 75%,
        #3b82f6 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1.5s ease-in-out infinite;
    }

    .status-indicator.team-active .status-detail {
      color: #06b6d4;
    }

    .status-detail {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    }

    .status-count {
      margin-left: auto;
      font-size: 11px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 2px 8px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* Simple typing dots fallback */
    .typing {
      align-self: flex-start;
      padding: 14px 18px;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      border-bottom-left-radius: 6px;
      display: flex;
      gap: 6px;
      animation: messageIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: typingBounce 1.4s infinite ease-in-out both;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; background: var(--accent); }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); }
    .typing-dot:nth-child(3) { animation-delay: 0s; background: var(--accent-secondary); }

    @keyframes typingBounce {
      0%, 80%, 100% {
        transform: scale(0.7) translateY(0);
        opacity: 0.4;
      }
      40% {
        transform: scale(1.1) translateY(-4px);
        opacity: 1;
      }
    }

    /* Input Area */
    #input-area {
      padding: 0 20px 20px 20px;
      background: var(--bg-secondary);
      display: flex;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }

    .input-container {
      flex: 1;
      display: flex;
      align-items: flex-end;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 4px;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .input-container:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.15), 0 0 20px rgba(168, 85, 247, 0.1);
    }

    .attach-btn {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
    }

    .attach-btn:hover {
      background: var(--border);
      color: var(--accent);
      transform: scale(1.1) rotate(-10deg);
    }

    .attach-btn:active {
      transform: scale(0.95) rotate(0deg);
    }

    .attach-btn svg {
      width: 18px;
      height: 18px;
    }

    #message-input {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      outline: none;
      resize: none;
      min-height: 24px;
      max-height: 150px;
      line-height: 1.5;
      position: relative;
      z-index: 1;
    }

    #message-input::placeholder {
      color: var(--text-muted);
    }

    #message-input.has-suggestion::placeholder {
      color: transparent;
    }

    .textarea-wrapper {
      position: relative;
      flex: 1;
      display: flex;
    }

    #ghost-suggestion {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      font-size: 14px;
      font-family: inherit;
      line-height: 1.5;
      color: var(--text-muted);
      pointer-events: none;
      white-space: pre-wrap;
      word-wrap: break-word;
      opacity: 0.6;
    }

    #ghost-suggestion .tab-hint {
      color: var(--accent);
      opacity: 0.7;
      font-size: 12px;
      margin-left: 8px;
    }

    #send-btn {
      width: 42px;
      height: 42px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%);
      color: white;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
      box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn:hover:not(:disabled) {
      transform: scale(1.08) rotate(-3deg);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.45), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn:active:not(:disabled) {
      transform: scale(0.95) rotate(0deg);
    }

    #send-btn:disabled {
      background: var(--bg-tertiary);
      color: var(--text-muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    #send-btn svg {
      width: 18px;
      height: 18px;
      transition: transform 0.2s ease;
    }

    #send-btn:hover:not(:disabled) svg {
      transform: scale(1.1);
    }

    #send-btn.stop-btn {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn.stop-btn:hover {
      background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.45);
      transform: scale(1.08);
    }

    /* Search Area */
    #search-area {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      min-height: 30px;
    }

    .search-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      height: 30px;
      box-sizing: border-box;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .search-toggle svg {
      width: 14px;
      height: 14px;
    }

    #search-area.searching .search-toggle {
      display: none;
    }

    #search-expanded {
      display: none;
      align-items: center;
      gap: 8px;
    }

    #search-area.searching #search-expanded {
      display: flex;
    }

    #search-expanded .search-icon {
      color: var(--text-muted);
      flex-shrink: 0;
    }

    #search-input {
      flex: 1;
      padding: 6px 0;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      outline: none;
      min-width: 0;
    }

    #search-input::placeholder {
      color: var(--text-muted);
    }

    .search-results-count {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .search-results-count.has-results {
      color: var(--accent);
    }

    .search-nav {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .search-nav-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-nav-btn:hover:not(:disabled) {
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .search-nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .search-nav-btn svg {
      width: 14px;
      height: 14px;
    }

    .search-close-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-close-btn:hover {
      background: var(--error);
      color: white;
    }

    .search-close-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Mode Toggle */
    #mode-toggle-area {
      flex-shrink: 0;
      display: flex;
      align-items: center;
    }

    .mode-toggle {
      display: flex;
      height: 30px;
      box-sizing: border-box;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .mode-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 12px;
      font-weight: 500;
      font-family: inherit;
      padding: 6px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .mode-btn:hover {
      color: var(--text-primary);
    }

    .mode-btn.active {
      background: var(--accent);
      color: #fff;
    }

    /* Toolbar row (search + workflows side by side) */
    #toolbar-row {
      display: flex;
      gap: 8px;
      padding: 10px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    /* Workflows Area */
    #workflows-area {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      min-height: 30px;
    }

    .workflows-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      height: 30px;
      box-sizing: border-box;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .workflows-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .workflows-toggle svg {
      width: 14px;
      height: 14px;
    }

    #workflows-area.active .workflows-toggle {
      display: none;
    }

    /* Chat Area */
    .chat-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      height: 30px;
      box-sizing: border-box;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .chat-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .chat-toggle svg {
      width: 14px;
      height: 14px;
    }

    .chat-toggle.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .chat-toggle {
      position: relative;
    }

    .chat-unread-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      background: #ef4444;
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      box-shadow: 0 0 0 2px var(--bg-secondary);
      animation: unread-pop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes unread-pop {
      0% { transform: scale(0); }
      100% { transform: scale(1); }
    }

    /* Global Chat Header */
    #global-chat-header {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 8px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    #global-chat-header .chat-back-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
    }

    #global-chat-header .chat-back-btn:hover {
      color: var(--accent);
      background: var(--bg-tertiary);
    }

    #global-chat-header .chat-back-btn svg {
      width: 16px;
      height: 16px;
    }

    #global-chat-header .chat-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .chat-username-badge {
      font-size: 11px;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: border-color 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 3px;
    }
    .chat-username-badge:hover {
      border-color: var(--accent);
    }

    #global-chat-header .chat-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
      opacity: 0.5;
    }

    #global-chat-header .chat-status.connected {
      background: #22c55e;
      opacity: 1;
    }


    /* Global Chat Messages */
    #global-chat-messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      display: none;
      flex-direction: column;
      gap: 16px;
      scroll-behavior: smooth;
    }

    .global-chat-wrapper {
      display: flex;
      flex-direction: column;
      max-width: 80%;
    }

    .global-chat-wrapper.self {
      align-self: flex-end;
      align-items: flex-end;
    }

    .global-chat-wrapper.other {
      align-self: flex-start;
      align-items: flex-start;
    }

    .global-chat-sender {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 3px;
      padding: 0 4px;
      color: var(--text-muted);
    }

    .verified-badge {
      display: inline-flex;
      align-items: center;
    }

    .verified-badge svg {
      width: 14px;
      height: 14px;
    }

    .message.global-chat-self {
      max-width: 100%;
      background: var(--user-bubble);
      color: #fff;
      padding: 12px 16px;
      border-radius: 16px 16px 4px 16px;
      font-size: 14px;
      line-height: 1.5;
      word-wrap: break-word;
    }

    .message.global-chat-other {
      max-width: 100%;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 12px 16px;
      border-radius: 16px 16px 16px 4px;
      font-size: 14px;
      line-height: 1.5;
      word-wrap: break-word;
    }

    .admin-username {
      background: linear-gradient(90deg, #60a5fa, #c084fc, #22d3ee, #f472b6, #818cf8, #a855f7, #60a5fa);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: admin-flow 6s linear infinite, admin-neon 4s ease-in-out infinite alternate;
      font-weight: 700;
      letter-spacing: 0.5px;
      position: relative;
      text-transform: uppercase;
    }

    @keyframes admin-flow {
      0% { background-position: 0% 50%; }
      100% { background-position: 300% 50%; }
    }

    @keyframes admin-neon {
      0% {
        filter:
          drop-shadow(0 0 3px rgba(96, 165, 250, 0.5))
          drop-shadow(0 0 6px rgba(168, 85, 247, 0.3));
      }
      50% {
        filter:
          drop-shadow(0 0 6px rgba(34, 211, 238, 0.7))
          drop-shadow(0 0 12px rgba(168, 85, 247, 0.5))
          drop-shadow(0 0 24px rgba(96, 165, 250, 0.3));
      }
      100% {
        filter:
          drop-shadow(0 0 4px rgba(168, 85, 247, 0.5))
          drop-shadow(0 0 10px rgba(96, 165, 250, 0.3));
      }
    }

    /* Glitch layer â€” occasional subtle slice */
    .admin-username::before {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(90deg, #22d3ee, #f472b6, #60a5fa);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: admin-glitch 8s ease-in-out infinite;
      opacity: 0;
      pointer-events: none;
    }

    @keyframes admin-glitch {
      0%, 90%, 100% { opacity: 0; transform: none; clip-path: inset(0); }
      91% { opacity: 0.8; transform: translate(2px, -1px) skewX(-3deg); clip-path: inset(0 0 55% 0); }
      92% { opacity: 0; transform: translate(-2px, 1px); clip-path: inset(40% 0 0 0); }
      93% { opacity: 0.6; transform: translate(1px, 0) skewX(2deg); clip-path: inset(20% 0 40% 0); }
      94% { opacity: 0; transform: none; clip-path: inset(0); }
    }

    /* --- Tier progression effects --- */

    .tier-badge {
      font-size: 12px;
      line-height: 1;
      display: inline-block;
    }

    /* Per-tier emoji animations */
    .tier-spark + .tier-spark-badge, .tier-badge-spark {
      animation: badge-flash 1.5s ease-in-out infinite;
    }
    .tier-badge-blaze {
      animation: badge-flicker 0.8s ease-in-out infinite alternate;
    }
    .tier-badge-storm {
      animation: badge-shake 2s ease-in-out infinite;
    }
    .tier-badge-frost {
      animation: badge-float 2.5s ease-in-out infinite;
    }
    .tier-badge-solar {
      animation: badge-glow-pulse 1.8s ease-in-out infinite;
    }
    .tier-badge-mystic {
      animation: badge-float 2s ease-in-out infinite, badge-glow-pulse 2.5s ease-in-out infinite;
    }
    .tier-badge-inferno {
      animation: badge-flicker 0.4s ease-in-out infinite alternate, badge-shake 1.5s ease-in-out infinite;
    }
    .tier-badge-cosmic {
      animation: badge-spin 4s linear infinite;
    }
    .tier-badge-legendary {
      animation: badge-bounce 1.2s ease-in-out infinite, badge-glow-pulse 1.5s ease-in-out infinite;
    }
    .tier-badge-mythic {
      animation: badge-bounce 1s ease-in-out infinite, badge-spin 6s linear infinite;
      filter: drop-shadow(0 0 4px rgba(192,132,252,0.6));
    }

    @keyframes badge-flash {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.15); }
    }
    @keyframes badge-flicker {
      0% { transform: scale(1) rotate(-3deg); opacity: 0.8; }
      100% { transform: scale(1.1) rotate(3deg); opacity: 1; }
    }
    @keyframes badge-shake {
      0%, 100% { transform: translateX(0); }
      15% { transform: translateX(-1.5px) rotate(-2deg); }
      30% { transform: translateX(1.5px) rotate(2deg); }
      45% { transform: translateX(-1px) rotate(-1deg); }
      60% { transform: translateX(1px); }
      75% { transform: translateX(0); }
    }
    @keyframes badge-float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }
    @keyframes badge-glow-pulse {
      0%, 100% { filter: drop-shadow(0 0 2px rgba(255,255,255,0.2)); transform: scale(1); }
      50% { filter: drop-shadow(0 0 6px rgba(255,255,255,0.6)); transform: scale(1.1); }
    }
    @keyframes badge-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes badge-bounce {
      0%, 100% { transform: translateY(0) scale(1); }
      40% { transform: translateY(-4px) scale(1.15); }
      60% { transform: translateY(-2px) scale(1.05); }
    }

    /* Tier 1: Spark â€” subtle yellow glow */
    .tier-spark {
      color: #facc15;
      text-shadow: 0 0 4px rgba(250,204,21,0.4);
    }

    /* Tier 2: Blaze â€” orange shimmer */
    .tier-blaze {
      background: linear-gradient(90deg, #f97316, #fbbf24, #f97316);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 3s linear infinite;
    }

    /* Tier 3: Storm â€” blue-purple pulse */
    .tier-storm {
      background: linear-gradient(90deg, #818cf8, #a78bfa, #818cf8);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 2.5s linear infinite;
      filter: drop-shadow(0 0 3px rgba(129,140,248,0.5));
    }

    /* Tier 4: Frost â€” cyan frost glow */
    .tier-frost {
      background: linear-gradient(90deg, #22d3ee, #67e8f9, #a5f3fc, #22d3ee);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 2.5s linear infinite;
      filter: drop-shadow(0 0 4px rgba(34,211,238,0.5));
    }

    /* Tier 5: Solar â€” gold radiance */
    .tier-solar {
      background: linear-gradient(90deg, #f59e0b, #fbbf24, #fde68a, #f59e0b);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 2s linear infinite;
      filter: drop-shadow(0 0 6px rgba(245,158,11,0.6));
    }

    /* Tier 6: Mystic â€” purple-pink flow */
    .tier-mystic {
      background: linear-gradient(90deg, #a855f7, #ec4899, #d946ef, #a855f7);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 2s linear infinite;
      filter: drop-shadow(0 0 5px rgba(168,85,247,0.5));
    }

    /* Tier 7: Inferno â€” red-orange fire text */
    .tier-inferno {
      background: linear-gradient(90deg, #ef4444, #f97316, #fbbf24, #ef4444);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 1.8s linear infinite, tier-pulse 2s ease-in-out infinite alternate;
      filter: drop-shadow(0 0 6px rgba(239,68,68,0.6));
    }

    /* Tier 8: Cosmic â€” rainbow gradient flow */
    .tier-cosmic {
      background: linear-gradient(90deg, #ef4444, #f97316, #facc15, #22c55e, #3b82f6, #8b5cf6, #ec4899, #ef4444);
      background-size: 400% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 3s linear infinite;
      filter: drop-shadow(0 0 6px rgba(139,92,246,0.5)) drop-shadow(0 0 10px rgba(59,130,246,0.3));
    }

    /* Tier 9: Legendary â€” multi-color glitch + glow */
    .tier-legendary {
      background: linear-gradient(90deg, #ef4444, #8b5cf6, #22d3ee, #facc15, #ec4899, #ef4444);
      background-size: 400% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 2s linear infinite;
      filter: drop-shadow(0 0 8px rgba(236,72,153,0.6)) drop-shadow(0 0 14px rgba(139,92,246,0.4));
      position: relative;
    }
    .tier-legendary::before {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(90deg, #22d3ee, #facc15, #ec4899);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-glitch 4s ease-in-out infinite;
      opacity: 0;
      pointer-events: none;
    }

    /* Tier 10: Mythic â€” electric plasma + particle shimmer */
    .tier-mythic {
      background: linear-gradient(90deg, #c084fc, #60a5fa, #22d3ee, #facc15, #f472b6, #c084fc);
      background-size: 500% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-shimmer 1.5s linear infinite, tier-pulse 1.5s ease-in-out infinite alternate;
      filter: drop-shadow(0 0 8px rgba(192,132,252,0.7)) drop-shadow(0 0 16px rgba(96,165,250,0.5)) drop-shadow(0 0 24px rgba(34,211,238,0.3));
      position: relative;
    }
    .tier-mythic::before {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(90deg, #22d3ee, #c084fc, #f472b6);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tier-glitch 3s ease-in-out infinite;
      opacity: 0;
      pointer-events: none;
    }

    @keyframes tier-shimmer {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    @keyframes tier-pulse {
      0% { filter: drop-shadow(0 0 4px currentColor); }
      100% { filter: drop-shadow(0 0 10px currentColor) drop-shadow(0 0 20px currentColor); }
    }

    @keyframes tier-glitch {
      0%, 85%, 100% { opacity: 0; transform: none; clip-path: inset(0); }
      86% { opacity: 0.8; transform: translate(2px, -1px) skewX(-2deg); clip-path: inset(0 0 60% 0); }
      87% { opacity: 0; transform: translate(-2px, 1px); clip-path: inset(40% 0 0 0); }
      88% { opacity: 0.6; transform: translate(1px, 0) skewX(1deg); clip-path: inset(20% 0 40% 0); }
      89% { opacity: 0; transform: none; clip-path: inset(0); }
    }

    /* Tier toast (success-style, not error) */
    .chat-toast.tier-toast::before {
      background: linear-gradient(90deg, #a855f7 0%, #ec4899 100%);
    }
    .chat-toast.tier-toast .toast-icon {
      background: linear-gradient(135deg, rgba(168,85,247,0.2) 0%, rgba(236,72,153,0.1) 100%);
      color: #c084fc;
    }

    /* Tier tooltip */
    .tier-tooltip {
      position: fixed;
      z-index: 2000;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 16px;
      min-width: 220px;
      max-width: 280px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      animation: tierTooltipIn 0.2s ease;
    }
    @keyframes tierTooltipIn {
      from { opacity: 0; transform: translateY(-6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .tier-tooltip-current {
      font-size: 14px;
      margin-bottom: 6px;
    }
    .tier-tooltip-next {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }
    .tier-tooltip-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }
    .tier-tooltip-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 260px;
      overflow-y: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .tier-tooltip-list::-webkit-scrollbar {
      display: none;
    }
    .tier-tooltip-row {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      padding: 5px 8px;
      border-radius: 6px;
      opacity: 0.75;
      background: rgba(255,255,255,0.02);
    }
    .tier-tooltip-row.active {
      opacity: 1;
      background: rgba(255,255,255,0.04);
    }
    .tier-tooltip-row.current {
      opacity: 1;
      background: rgba(168,85,247,0.12);
      border: 1px solid rgba(168,85,247,0.3);
      box-shadow: 0 0 8px rgba(168,85,247,0.1);
    }
    .tier-tooltip-badge {
      font-size: 16px;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
      display: inline-block;
    }
    .tier-tooltip-name {
      flex: 1;
      font-weight: 600;
    }
    .tier-tooltip-name-preview {
      flex: 1;
      font-weight: 600;
      font-size: 11px;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .tier-tooltip-name-preview span {
      position: relative;
    }
    .tier-tooltip-tier-label {
      font-size: 10px;
      color: var(--text-muted);
      flex-shrink: 0;
      width: 58px;
      text-align: right;
    }
    .tier-tooltip-threshold {
      color: var(--text-muted);
      font-size: 11px;
      flex-shrink: 0;
    }
    .tier-tooltip-you {
      font-size: 9px;
      font-weight: 700;
      color: var(--accent);
      background: rgba(168,85,247,0.15);
      padding: 1px 5px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .admin-badge {
      display: none;
      border: 1px solid rgba(245, 158, 11, 0.3);
    }

    .message.global-chat-admin {
      border-left: 2px solid #f59e0b;
    }

    /* Admin gear menu in global chat header */
    #admin-menu-wrap {
      position: relative;
      margin-left: auto;
    }
    #admin-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 160px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 200;
      overflow: hidden;
    }
    #admin-dropdown.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    /* Admin tier popover */
    .admin-tier-popover {
      position: fixed;
      z-index: 1000;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      min-width: 200px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      animation: tierTooltipIn 0.2s ease;
    }
    .atp-header {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text-primary);
    }
    .atp-current {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .atp-floor {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .atp-floor-label {
      flex: 1;
    }
    .atp-btn {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      padding: 0;
      line-height: 1;
    }
    .atp-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .chat-toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      min-width: 200px;
      max-width: 360px;
      background: rgba(28, 28, 30, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 14px 18px;
      border-radius: 14px;
      font-size: 13px;
      font-weight: 500;
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 1000;
      overflow: hidden;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      color: var(--text-primary);
    }

    .chat-toast.show {
      display: flex;
      animation: chatToastSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .chat-toast.exiting {
      animation: chatToastSlideOut 0.3s cubic-bezier(0.4, 0, 1, 1) forwards;
    }

    .chat-toast::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      width: 100%;
      background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
      animation: chatToastProgress 2.5s linear forwards;
      transform-origin: left;
    }

    .chat-toast .toast-icon {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
      color: #f87171;
    }

    .chat-toast .toast-icon svg {
      width: 18px;
      height: 18px;
    }

    .chat-toast .toast-message {
      color: var(--text-primary);
      line-height: 1.4;
      white-space: nowrap;
    }

    @keyframes chatToastSlideIn {
      0% { transform: translateX(100%) scale(0.8); opacity: 0; }
      100% { transform: translateX(0) scale(1); opacity: 1; }
    }

    @keyframes chatToastSlideOut {
      0% { transform: translateX(0) scale(1); opacity: 1; }
      100% { transform: translateX(100%) scale(0.8); opacity: 0; }
    }

    @keyframes chatToastProgress {
      from { transform: scaleX(1); }
      to { transform: scaleX(0); }
    }

    .global-chat-empty {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      color: var(--text-secondary);
      font-size: 13px;
      opacity: 0.6;
      text-align: center;
      padding: 40px;
    }

    #workflows-expanded {
      display: none;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #workflows-area.active #workflows-expanded {
      display: flex;
    }

    #workflows-grid {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .workflow-btn {
      padding: 6px 12px;
      background: rgba(168, 85, 247, 0.12);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 16px;
      color: var(--accent-hover);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      font-family: inherit;
    }

    .workflow-btn:hover {
      background: rgba(168, 85, 247, 0.25);
      border-color: var(--accent);
      color: white;
      transform: translateY(-1px);
    }

    .workflows-close-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .workflows-close-btn:hover {
      background: var(--error);
      color: white;
    }

    .workflows-close-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Background Tasks Area */
    #background-tasks-area {
      flex-shrink: 0;
      margin-left: auto;
      position: relative;
    }

    .background-tasks-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .background-tasks-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .bg-task-pulse {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      animation: bgPulse 1.5s ease-in-out infinite;
    }

    @keyframes bgPulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.4); }
      50% { opacity: 0.6; box-shadow: 0 0 0 4px rgba(168, 85, 247, 0); }
    }

    .bg-task-count {
      font-weight: 700;
      font-size: 11px;
      min-width: 14px;
      text-align: center;
    }

    /* Dropdown (hidden by default, appears above the toggle) */
    #background-tasks-dropdown {
      display: none;
      position: absolute;
      bottom: calc(100% + 6px);
      right: 0;
      min-width: 260px;
      max-width: 340px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      z-index: 50;
    }

    #background-tasks-area.active #background-tasks-dropdown {
      display: block;
    }

    .bg-dropdown-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-tertiary);
    }

    .bg-dropdown-back {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .bg-dropdown-back:hover {
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .bg-dropdown-back svg {
      width: 16px;
      height: 16px;
    }

    .bg-dropdown-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    #background-tasks-list {
      display: flex;
      flex-direction: column;
      max-height: 200px;
      overflow-y: auto;
    }

    .bg-task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      color: var(--text-primary);
      transition: background 0.15s ease;
    }

    .bg-task-item:last-child {
      border-bottom: none;
    }

    .bg-task-item:hover {
      background: rgba(168, 85, 247, 0.05);
    }

    .bg-task-item .bg-task-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      flex-shrink: 0;
      animation: bgPulse 1.5s ease-in-out infinite;
    }

    .bg-task-item .bg-task-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text-secondary);
    }

    .bg-task-item .bg-task-type {
      font-size: 10px;
      font-weight: 600;
      color: var(--accent-hover);
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .bg-task-item .bg-task-close {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.15s ease;
      opacity: 0;
    }

    .bg-task-item:hover .bg-task-close {
      opacity: 1;
    }

    .bg-task-close:hover {
      background: var(--error);
      color: white;
    }

    .bg-task-close svg {
      width: 12px;
      height: 12px;
    }

    /* Workflow badge in input area */
    .workflow-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 3px 10px;
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
      border: 1px solid rgba(168, 85, 247, 0.4);
      border-radius: 12px;
      color: var(--accent-hover);
      font-size: 11px;
      font-weight: 600;
      font-family: inherit;
      margin-right: 6px;
      flex-shrink: 0;
    }

    .workflow-badge-remove {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      background: transparent;
      border: none;
      border-radius: 50%;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
      padding: 0;
    }

    .workflow-badge-remove:hover {
      color: var(--error);
    }

    .workflow-badge-remove svg {
      width: 10px;
      height: 10px;
    }

    #workflow-badge-container {
      display: flex;
      align-items: center;
      align-self: center;
    }

    /* Search highlight */
    mark.search-highlight {
      background: rgba(168, 85, 247, 0.4);
      color: inherit;
      border-radius: 2px;
      padding: 0 2px;
    }

    mark.search-highlight.current {
      background: var(--accent);
      color: white;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      gap: 16px;
      padding: 40px;
      animation: emptyStateIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes emptyStateIn {
      0% {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .empty-state .pixel-heart {
      width: 4px;
      height: 4px;
      margin: 20px auto 30px;
      position: relative;
      left: -14px;
      background: transparent;
      animation: pixelheart-pulse 1.2s ease-in-out infinite;
      image-rendering: pixelated;
      box-shadow:
        /* Row 1 */
        4px 0 0 var(--accent), 8px 0 0 var(--accent),
        20px 0 0 var(--accent-secondary), 24px 0 0 var(--accent-secondary),
        /* Row 2 */
        0 4px 0 var(--accent), 4px 4px 0 var(--accent), 8px 4px 0 var(--accent), 12px 4px 0 var(--accent),
        16px 4px 0 var(--accent-secondary), 20px 4px 0 var(--accent-secondary), 24px 4px 0 var(--accent-secondary), 28px 4px 0 var(--accent-secondary),
        /* Row 3 */
        0 8px 0 var(--accent), 4px 8px 0 var(--accent), 8px 8px 0 var(--accent), 12px 8px 0 #c084fc,
        16px 8px 0 #c084fc, 20px 8px 0 var(--accent-secondary), 24px 8px 0 var(--accent-secondary), 28px 8px 0 var(--accent-secondary),
        /* Row 4 */
        0 12px 0 var(--accent), 4px 12px 0 var(--accent), 8px 12px 0 #c084fc, 12px 12px 0 #c084fc,
        16px 12px 0 #c084fc, 20px 12px 0 #c084fc, 24px 12px 0 var(--accent-secondary), 28px 12px 0 var(--accent-secondary),
        /* Row 5 */
        4px 16px 0 var(--accent), 8px 16px 0 #c084fc, 12px 16px 0 #c084fc,
        16px 16px 0 #c084fc, 20px 16px 0 #c084fc, 24px 16px 0 var(--accent-secondary),
        /* Row 6 */
        8px 20px 0 #c084fc, 12px 20px 0 #c084fc, 16px 20px 0 #c084fc, 20px 20px 0 #c084fc,
        /* Row 7 */
        12px 24px 0 #c084fc, 16px 24px 0 #c084fc,
        /* Row 8 - tip */
        14px 28px 0 #c084fc;
    }

    @keyframes pixelheart-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }

    .empty-state .empty-title {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .empty-state .empty-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      text-align: center;
      max-width: 280px;
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      opacity: 0.5;
    }

    .empty-state p {
      font-size: 14px;
      text-align: center;
    }

    /* Date separator timestamp */
    .timestamp {
      font-size: 11px;
      color: var(--text-muted);
      text-align: center;
      padding: 8px 0;
    }

    /* Message footer (copy + timestamp) */
    .message-footer {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 6px;
    }

    .message-copy-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      opacity: 0;
      transition: all 0.15s ease;
      padding: 0;
    }

    .message:hover .message-copy-btn {
      opacity: 0.6;
    }

    .message-copy-btn:hover {
      opacity: 1 !important;
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .message-copy-btn.copied {
      opacity: 1 !important;
      color: var(--success);
    }

    .message-copy-btn svg {
      width: 12px;
      height: 12px;
    }

    .message.user .message-copy-btn {
      color: rgba(255, 255, 255, 0.5);
    }

    .message.user .message-copy-btn:hover {
      color: white;
      background: rgba(255, 255, 255, 0.15);
    }

    .message.user .message-copy-btn.copied {
      color: white;
    }

    .message-timestamp {
      font-size: 10px;
      color: var(--text-muted);
      opacity: 0.7;
    }

    .message.user .message-timestamp {
      color: rgba(255, 255, 255, 0.6);
    }

    /* File Input (hidden) */
    #file-input {
      display: none;
    }

    /* Attachments */
    .attachments-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-top: 1px solid var(--border);
      max-height: 120px;
      overflow-y: auto;
    }

    .attachment-preview {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
      max-width: 200px;
    }

    .attachment-preview img {
      width: 32px;
      height: 32px;
      object-fit: cover;
      border-radius: 4px;
    }

    .attachment-icon {
      min-width: 28px;
      height: 24px;
      padding: 0 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      flex-shrink: 0;
      box-sizing: border-box;
    }

    .attachment-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .attachment-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .attachment-size {
      font-size: 11px;
      color: var(--text-muted);
    }

    .attachment-remove {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1;
      padding: 0;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .attachment-remove:hover {
      background: var(--error);
      color: white;
    }

    /* Drag and Drop Overlay */
    .drag-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(168, 85, 247, 0.1);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: none;
    }

    .drag-overlay.active {
      display: flex;
    }

    .drag-overlay-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 48px 64px;
      background: var(--bg-secondary);
      border: 2px dashed var(--accent);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(168, 85, 247, 0.2);
    }

    .drag-overlay-icon {
      width: 64px;
      height: 64px;
      color: var(--accent);
      animation: bounce 0.6s ease infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .drag-overlay-text {
      font-size: 18px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .drag-overlay-hint {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* Attachment in messages */
    .message-attachments {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .message-attachment {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.3;
      margin: 2px 0;
    }

    .message-attachment img {
      max-width: 200px;
      max-height: 150px;
      border-radius: 6px;
    }

    /* Response media images (from agent screenshots/tools) */
    .message-media {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .message-media img {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .message-media img:hover {
      opacity: 0.9;
    }

    .message img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
  <script>
    (function(){function _apply(p){var r=document.documentElement;if(!p){['bg-primary','bg-secondary','bg-tertiary','border','text-primary','text-secondary','text-muted','accent','accent-secondary','accent-hover','error','success','warning','orange','user-bubble','user-bubble-solid','assistant-bubble'].forEach(function(k){r.style.removeProperty('--'+k)});return}Object.keys(p).forEach(function(k){r.style.setProperty('--'+k,p[k])})}window.addEventListener('DOMContentLoaded',function(){if(!window.pocketAgent)return;Promise.all([window.pocketAgent.getThemes(),window.pocketAgent.getSkin()]).then(function(res){var themes=res[0],skinId=res[1],t=themes[skinId];if(t)_apply(t.palette);window.pocketAgent.onSkinChanged(function(id){var th=themes[id];if(th)_apply(th.palette)})}).catch(function(){})})})();
  </script>
</head>
<body>
  <header>
    <div class="header-left">
      <img src="../assets/tray-icon@2x.png" alt="" class="header-logo">
      <h1>Pocket Agent<span id="version-badge" class="version-badge"></span><select id="model-badge" class="model-badge"></select><span id="update-badge" class="update-badge" onclick="openSettings('updates')">Update</span></h1>
    </div>
    <div class="header-right">
      <div class="stats" id="stats"></div>
      <span class="chat-username-badge" id="chat-username-badge" style="display: none;"></span>
      <div class="stats" id="chat-online-stats" style="display: none;">0 online Â· 0 in chat</div>
      <div class="hamburger-menu">
        <button class="hamburger-btn" onclick="playNormalClick(); toggleMenu()" id="hamburger-btn">
          <span></span>
          <span></span>
          <span></span>
        </button>
        <div class="menu-dropdown" id="menu-dropdown">
          <button class="menu-item" onclick="playNormalClick(); clearChat(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
              <path d="M3 3v5h5"/>
            </svg>
            Fresh Start
          </button>
          <button class="menu-item" onclick="playNormalClick(); showFacts(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2a10 10 0 1 0 10 10H12V2z"/>
              <path d="M12 2a10 10 0 0 1 10 10"/>
              <circle cx="12" cy="12" r="6"/>
              <circle cx="12" cy="12" r="2"/>
            </svg>
            My Brain
          </button>
          <button class="menu-item" onclick="playNormalClick(); showDailyLogs(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
              <line x1="16" y1="2" x2="16" y2="6"/>
              <line x1="8" y1="2" x2="8" y2="6"/>
              <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
            Daily Logs
          </button>
          <button class="menu-item" onclick="playNormalClick(); showSoul(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
            My Approach
          </button>
          <button class="menu-item" onclick="playNormalClick(); openFactsGraph(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="6" cy="6" r="3"/>
              <circle cx="18" cy="6" r="3"/>
              <circle cx="6" cy="18" r="3"/>
              <circle cx="18" cy="18" r="3"/>
              <line x1="8.5" y1="7.5" x2="15.5" y2="16.5"/>
              <line x1="15.5" y1="7.5" x2="8.5" y2="16.5"/>
            </svg>
            Mind Map
          </button>
          <button class="menu-item" onclick="playNormalClick(); openCustomize(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 20h9"/>
              <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>
            </svg>
            Personalize
          </button>
          <button class="menu-item" onclick="playNormalClick(); openRoutines(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
            Routines
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openDocs(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
              <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
            </svg>
            Docs
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openSettings(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"/>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
            </svg>
            Settings
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openAbout(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
              <line x1="12" y1="17" x2="12.01" y2="17"/>
            </svg>
            Who made me?
          </button>
        </div>
      </div>
    </div>
  </header>

  <!-- About Modal -->
  <div class="modal-overlay" id="about-modal" onclick="if(event.target === this) closeAbout();">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-icon pixel-cat"></div>
        <div class="modal-title">
          <h2>who made me?</h2>
          <p>the human behind franky</p>
        </div>
        <button class="modal-close" onclick="playNormalClick(); closeAbout();">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <div class="about-content">
          <p>i was built by <strong>Ken Kai</strong> - he's been obsessed with AI and AI development for over 10 years now</p>
          <p>he runs a youtube channel where he shares everything he learns, and teaches on skool too</p>
          <p>if you want to learn more about AI dev, agents, and building cool stuff like me - check him out:</p>
        </div>
        <div class="about-links">
          <a class="about-link" onclick="playNormalClick(); window.pocketAgent.openExternal('https://www.youtube.com/@kenkaidoesai')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
            </svg>
            <span>@kenkaidoesai</span>
            <small>YouTube</small>
          </a>
          <a class="about-link" onclick="playNormalClick(); window.pocketAgent.openExternal('https://www.skool.com/kenkai')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
              <path d="M6 12v5c3 3 9 3 12 0v-5"/>
            </svg>
            <span>skool.com/kenkai</span>
            <small>Learn AI Dev</small>
          </a>
        </div>
      </div>
    </div>
  </div>

  <div class="tabs-container" id="tabs-container">
    <!-- Tabs will be populated by JavaScript -->
    <button class="new-tab-btn" onclick="playNormalClick(); createNewSession()" title="New chat">+</button>
  </div>

  <div id="global-chat-header">
    <button class="chat-back-btn" onclick="playNormalClick(); toggleGlobalChat()" title="Back to agent">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    </button>
    <span class="chat-title">global chat</span>
    <span class="chat-status" id="chat-status-dot"></span>
    <div id="admin-menu-wrap" style="display:none;">
      <button id="admin-gear-btn" class="chat-back-btn" title="Admin">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      </button>
      <div id="admin-dropdown">
        <button class="menu-item danger" id="admin-clear-chat">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
          <span>Clear Chat</span>
        </button>
      </div>
    </div>
  </div>

  <div id="messages"></div>
  <div id="global-chat-messages"></div>
  <div class="chat-toast" id="chat-toast"></div>

  <!-- Scroll Buttons -->
  <button id="scroll-top-btn" class="scroll-btn" onclick="playNormalClick(); scrollToTop()" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>
  <button id="scroll-bottom-btn" class="scroll-btn" onclick="playNormalClick(); scrollToBottom()" title="Scroll to bottom">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  </button>

  <!-- Global Chat Scroll Buttons -->
  <button id="gchat-scroll-top-btn" class="scroll-btn gchat-scroll-btn" onclick="playNormalClick(); gchatScrollToTop()" title="Scroll to top" style="display:none">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>
  <button id="gchat-scroll-bottom-btn" class="scroll-btn gchat-scroll-btn" onclick="playNormalClick(); gchatScrollToBottom()" title="Scroll to bottom" style="display:none">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  </button>

  <!-- Toolbar Row (Mode Toggle + Search + Workflows) -->
  <div id="toolbar-row">
    <div id="mode-toggle-area">
      <div class="mode-toggle">
        <button class="mode-btn" id="mode-btn-general" onclick="playNormalClick(); setAgentMode('general')">General</button>
        <button class="mode-btn active" id="mode-btn-coder" onclick="playNormalClick(); setAgentMode('coder')">Coder</button>
      </div>
    </div>
    <div id="search-area">
      <!-- Toggle Button (shown by default) -->
      <button class="search-toggle" id="search-toggle-btn" onclick="playNormalClick(); toggleSearch()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
        <span>search</span>
      </button>
      <!-- Search Input (hidden by default) -->
      <div id="search-expanded">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
        <input type="text" id="search-input" placeholder="Search in chat..." oninput="handleSearchInput(event)" onkeydown="handleSearchKeydown(event)">
        <span id="search-results-count" class="search-results-count"></span>
        <div class="search-nav">
          <button class="search-nav-btn" id="search-prev-btn" onclick="playNormalClick(); navigateSearch(-1)" title="Previous" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
          </button>
          <button class="search-nav-btn" id="search-next-btn" onclick="playNormalClick(); navigateSearch(1)" title="Next" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
        </div>
        <button class="search-close-btn" onclick="playNormalClick(); closeSearch()" title="Close">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Workflows Area -->
    <div id="workflows-area">
      <button class="workflows-toggle" onclick="playNormalClick(); toggleWorkflows()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="16 18 22 12 16 6"></polyline>
          <polyline points="8 6 2 12 8 18"></polyline>
        </svg>
        <span>workflows</span>
      </button>
      <div id="workflows-expanded">
        <div id="workflows-grid"></div>
        <button class="workflows-close-btn" onclick="playNormalClick(); closeWorkflows()" title="Close">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Chat Area -->
    <div id="chat-area">
      <button class="chat-toggle" id="chat-toggle-btn" onclick="playNormalClick(); toggleGlobalChat()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        <span>chat</span>
      </button>
    </div>

    <!-- Background Tasks Indicator (pushed to right) -->
    <div id="background-tasks-area" style="display: none;">
      <button class="background-tasks-toggle" onclick="playNormalClick(); toggleBackgroundTasks()">
        <span class="bg-task-pulse"></span>
        <span class="bg-task-count">0</span>
        <span>background</span>
      </button>
      <div id="background-tasks-dropdown">
        <div class="bg-dropdown-header">
          <button class="bg-dropdown-back" onclick="playNormalClick(); closeBackgroundTasks()" title="Close">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <span class="bg-dropdown-title">Background Tasks</span>
        </div>
        <div id="background-tasks-list"></div>
      </div>
    </div>
  </div>

  <div id="input-area">
    <div class="input-container">
      <button class="attach-btn" onclick="playNormalClick(); triggerAttach()" title="Drop a file">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/>
        </svg>
      </button>
      <span id="workflow-badge-container"></span>
      <div class="textarea-wrapper">
        <div id="ghost-suggestion"></div>
        <textarea
          id="message-input"
          placeholder="what's on your mind? ðŸ±"
          rows="1"
          onkeydown="handleKeydown(event)"
          oninput="handleInput(event)"
        ></textarea>
      </div>
    </div>
    <button id="send-btn" onclick="handleSendClick()" title="Pounce! ðŸ¾">
      <svg class="send-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <!-- Paw pad (main) -->
        <ellipse cx="12" cy="14" rx="5" ry="4.5"/>
        <!-- Toe beans -->
        <ellipse cx="7" cy="8" rx="2" ry="2.5"/>
        <ellipse cx="17" cy="8" rx="2" ry="2.5"/>
        <ellipse cx="10" cy="5.5" rx="1.8" ry="2.2"/>
        <ellipse cx="14" cy="5.5" rx="1.8" ry="2.2"/>
      </svg>
      <svg class="stop-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <rect x="6" y="6" width="12" height="12" rx="2"/>
      </svg>
    </button>
  </div>

  <input type="file" id="file-input" onchange="handleFileSelect(event)" multiple
    accept=".txt,.md,.json,.csv,.xml,.html,.htm,.css,.js,.ts,.jsx,.tsx,.py,.rb,.go,.rs,.java,.c,.cpp,.h,.hpp,.sh,.yaml,.yml,.toml,.ini,.cfg,.conf,.log,.sql,.graphql,.pdf,.png,.jpg,.jpeg,.gif,.webp,.svg,.bmp,.ico">

  <!-- Click Sounds -->
  <audio id="click-sound" preload="auto" src="../assets/click.mp3"></audio>
  <audio id="normal-click-sound" preload="auto" src="../assets/normal-click.mp3"></audio>

  <!-- Drag and Drop Overlay -->
  <div id="drag-overlay" class="drag-overlay">
    <div class="drag-overlay-content">
      <svg class="drag-overlay-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
      <div class="drag-overlay-text">Drop files here</div>
      <div class="drag-overlay-hint">Images, PDFs, code, and text files supported</div>
    </div>
  </div>

  <script>
    const messagesDiv = document.getElementById('messages');
    const input = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const statsDiv = document.getElementById('stats');
    const fileInput = document.getElementById('file-input');

    let isLoadingBySession = new Map(); // Track loading state per session
    let pendingAttachmentsBySession = new Map(); // Track attachments per session
    let statusCleanupBySession = new Map(); // Track status listeners per session

    // Ensure a status listener exists for a session (called on session load + send)
    function ensureStatusListener(sessionId) {
      if (!statusCleanupBySession.has(sessionId)) {
        const statusCleanup = window.pocketAgent.onStatus((status) => {
          updateStatusIndicator(status, sessionId);
        });
        statusCleanupBySession.set(sessionId, statusCleanup);
      }
    }
    let statusElBySession = new Map(); // Track status elements per session
    let streamingBubbleBySession = new Map(); // Track live-updating assistant bubble per session
    let toolCountBySession = new Map(); // Track tool call count per session
    let suggestionBySession = new Map(); // Track ghost suggestions per session
    let inputTextBySession = new Map(); // Track input text per session
    let searchTextBySession = new Map(); // Track search input text per session
    let searchOpenBySession = new Map(); // Track search open state per session
    let queuedMessageIdsBySession = new Map(); // Track queued message IDs per session
    let pendingUserMessagesBySession = new Map(); // Track pending user message content per session
    const ghostSuggestion = document.getElementById('ghost-suggestion');
    let queuedMessageElements = new Map(); // Track queued message DOM elements by a unique ID

    // Helper to get current session's pending attachments
    function getPendingAttachments() {
      return pendingAttachmentsBySession.get(currentSessionId) || [];
    }
    function setPendingAttachments(attachments) {
      pendingAttachmentsBySession.set(currentSessionId, attachments);
    }
    // Helper to get current session's suggestion
    function getCurrentSuggestion() {
      return suggestionBySession.get(currentSessionId) || null;
    }
    function setCurrentSuggestion(suggestion) {
      suggestionBySession.set(currentSessionId, suggestion);
    }

    // Notification sound
    let notificationSound = null;
    let soundEnabled = true; // Will be loaded from settings

    // Initialize notification sound
    async function initNotificationSound() {
      try {
        soundEnabled = (await window.pocketAgent.getSetting('notifications.soundEnabled')) !== 'false';
        notificationSound = new Audio('../assets/pop.mp3');
        notificationSound.volume = 0.5;
      } catch (e) {
        console.warn('Failed to initialize notification sound:', e);
      }
    }

    // Play notification sound when response completes
    function playNotificationSound() {
      if (soundEnabled && notificationSound) {
        notificationSound.currentTime = 0;
        notificationSound.play().catch(() => {});
      }
    }

    // Click sounds
    const clickSound = document.getElementById('click-sound');
    const normalClickSound = document.getElementById('normal-click-sound');

    function playSendClick() {
      if (soundEnabled && clickSound) {
        clickSound.currentTime = 0;
        clickSound.play().catch(() => {});
      }
    }

    function playNormalClick() {
      if (soundEnabled && normalClickSound) {
        normalClickSound.currentTime = 0;
        normalClickSound.play().catch(() => {});
      }
    }

    // Session state
    const MAX_TABS = 5;
    let sessions = [];
    let currentSessionId = 'default';
    const tabsContainer = document.getElementById('tabs-container');

    // Global chat state
    let globalChatMode = false;
    let globalChatUsername = '';
    let globalChatMessages = [];
    let chatWs = null;
    let chatWsReconnectTimer = null;
    let chatAdminKey = '';
    let chatIsAdmin = false;
    let globalChatSelfTier = 0;
    let chatUnreadCount = 0;
    const userMinTierMap = new Map(); // username -> minTier

    const TIER_CONFIG = [
      { name: '', threshold: 0, badge: '', cssClass: '' },
      { name: 'Spark', threshold: 10, badge: '\u26A1', cssClass: 'tier-spark' },
      { name: 'Blaze', threshold: 25, badge: '\uD83D\uDD25', cssClass: 'tier-blaze' },
      { name: 'Storm', threshold: 50, badge: '\u26C8\uFE0F', cssClass: 'tier-storm' },
      { name: 'Frost', threshold: 80, badge: '\u2744\uFE0F', cssClass: 'tier-frost' },
      { name: 'Solar', threshold: 120, badge: '\u2600\uFE0F', cssClass: 'tier-solar' },
      { name: 'Mystic', threshold: 175, badge: '\uD83D\uDD2E', cssClass: 'tier-mystic' },
      { name: 'Inferno', threshold: 250, badge: '\uD83D\uDC80', cssClass: 'tier-inferno' },
      { name: 'Cosmic', threshold: 350, badge: '\uD83C\uDF0C', cssClass: 'tier-cosmic' },
      { name: 'Legendary', threshold: 500, badge: '\u2694\uFE0F', cssClass: 'tier-legendary' },
      { name: 'Mythic', threshold: 750, badge: '\uD83D\uDC51', cssClass: 'tier-mythic' },
    ];
    const CHAT_WS_URL = 'wss://pocket-agent-chat-production.up.railway.app';
    const CHAT_API_URL = 'https://pocket-agent-chat-production.up.railway.app';

    // Allowed file types
    const ALLOWED_EXTENSIONS = new Set([
      // Text/Code
      'txt', 'md', 'json', 'csv', 'xml', 'html', 'htm', 'css', 'js', 'ts', 'jsx', 'tsx',
      'py', 'rb', 'go', 'rs', 'java', 'c', 'cpp', 'h', 'hpp', 'sh', 'yaml', 'yml',
      'toml', 'ini', 'cfg', 'conf', 'log', 'sql', 'graphql',
      // Images
      'png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico',
      // Documents
      'pdf', 'docx', 'doc', 'rtf', 'odt', 'pages',
      'xlsx', 'xls', 'ods', 'numbers',
      'pptx', 'ppt', 'odp', 'keynote',
      'epub', 'zip', 'tar', 'gz'
    ]);

    const IMAGE_EXTENSIONS = new Set(['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico']);
    const EXTRACTABLE_EXTENSIONS = new Set([
      'docx', 'pptx', 'xlsx', 'odt', 'odp', 'ods', 'rtf'
    ]);
    const BINARY_EXTENSIONS = new Set([
      'pdf', 'doc', 'pages',
      'xls', 'numbers',
      'ppt', 'keynote',
      'epub', 'zip', 'tar', 'gz'
    ]);
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

    // Initialize
    window.addEventListener('DOMContentLoaded', async () => {
      // Load app version
      try {
        const version = await window.pocketAgent.getAppVersion();
        document.getElementById('version-badge').textContent = `v${version}`;
      } catch (err) {
        console.error('Failed to load app version:', err);
      }

      // Load current model
      await updateModelBadge();

      // Load current agent mode
      await initAgentMode();

      // Refresh model badge when window gains focus (in case user changed it in settings)
      window.addEventListener('focus', updateModelBadge);

      // Check for updates (delayed to not slow down startup)
      setTimeout(checkForUpdates, 3000);

      // Load sessions first, then load history for active session
      await loadSessions();
      ensureStatusListener(currentSessionId);
      await loadHistory();
      updateStats();
      input.focus();

      // Initialize notification sound
      initNotificationSound();

      // Connect to global chat server (stay online while app is open)
      await getOrCreateChatUsername();
      connectChatWs();

      // Listen for chat username changes from settings window
      window.pocketAgent.onChatUsernameChanged((newUsername) => {
        console.log('[Chat] Username changed via settings:', newUsername);
        globalChatUsername = newUsername;
        // Clear any pending reconnect timer and reconnect with new username
        clearTimeout(chatWsReconnectTimer);
        if (chatWs) {
          chatWs.onclose = null; // Prevent auto-reconnect with old handler
          chatWs.close();
          chatWs = null;
        }
        connectChatWs();
        // Update header badge if in chat mode
        if (globalChatMode) updateHeaderTierBadge();
      });

      // Listen for scheduler messages
      window.pocketAgent.onSchedulerMessage((data) => {
        console.log('[Chat] Received scheduler message:', data.jobName, 'sessionId:', data.sessionId, 'currentSession:', currentSessionId);
        handleSchedulerMessage(data);
      });

      // Listen for Telegram messages (cross-channel sync)
      console.log('[Chat] Setting up Telegram message listener');
      window.pocketAgent.onTelegramMessage((data) => {
        console.log('[Chat] Received Telegram message:', data);
        handleTelegramMessage(data);
      });
      console.log('[Chat] Telegram message listener set up');

      // Listen for iOS messages (cross-channel sync)
      window.pocketAgent.onIOSMessage((data) => {
        console.log('[Chat] Received iOS message:', data);
        handleIOSMessage(data);
      });

      // Listen for session clears from iOS
      window.pocketAgent.onSessionCleared((sessionId) => {
        console.log('[Chat] Session cleared from iOS:', sessionId);
        if (sessionId === currentSessionId) {
          messagesDiv.innerHTML = '';
          showEmptyState();
          updateStats();
        }
      });

      // Listen for session changes (e.g., Telegram link/unlink)
      window.pocketAgent.onSessionsChanged(() => {
        console.log('[Chat] Sessions changed, reloading...');
        loadSessions();
      });

      // Listen for model changes (e.g., changed via Telegram)
      window.pocketAgent.onModelChanged((model) => {
        console.log('[Chat] Model changed to:', model);
        updateModelBadge();
      });
    });

    // ============ SESSION MANAGEMENT ============

    async function loadSessions() {
      try {
        sessions = await window.pocketAgent.getSessions();
        // Restore last selected session from localStorage, or default to first session
        // Must be set BEFORE renderTabs() so the correct tab is highlighted
        if (sessions.length > 0) {
          const savedSessionId = localStorage.getItem('currentSessionId');
          const sessionExists = savedSessionId && sessions.some(s => s.id === savedSessionId);
          currentSessionId = sessionExists ? savedSessionId : sessions[0].id;
          // Save in case we defaulted to first session
          localStorage.setItem('currentSessionId', currentSessionId);
        }
        renderTabs();
      } catch (err) {
        console.error('Failed to load sessions:', err);
      }
    }

    let draggedTab = null;
    let draggedSessionId = null;

    function renderTabs() {
      // Remove existing tabs (keep the new tab button)
      const existingTabs = tabsContainer.querySelectorAll('.tab');
      existingTabs.forEach(tab => tab.remove());

      // Add tabs before the new tab button
      const newTabBtn = tabsContainer.querySelector('.new-tab-btn');

      sessions.forEach((session, index) => {
        const tab = document.createElement('div');
        const isActive = session.id === currentSessionId;
        const isLoading = isLoadingBySession.get(session.id);
        tab.className = 'tab' + (isActive ? ' active' : '') + (isLoading ? ' loading' : '');
        tab.dataset.sessionId = session.id;
        tab.dataset.index = index;
        tab.draggable = true;

        tab.onclick = (e) => {
          if (!e.target.closest('.tab-close') && !e.target.closest('.tab-name-input')) {
            playNormalClick();
            switchSession(session.id);
          }
        };
        tab.ondblclick = () => startRenameSession(session.id);

        // Drag events
        tab.ondragstart = (e) => {
          draggedTab = tab;
          draggedSessionId = session.id;
          setTimeout(() => tab.classList.add('dragging'), 0);
          e.dataTransfer.effectAllowed = 'move';
        };

        tab.ondragend = () => {
          if (draggedTab) {
            draggedTab.classList.remove('dragging');
          }
          draggedTab = null;
          draggedSessionId = null;
        };

        tab.ondragover = (e) => {
          e.preventDefault();
          if (!draggedTab || draggedSessionId === session.id) return;

          // Get the tab being hovered over
          const targetTab = tab;
          const rect = targetTab.getBoundingClientRect();
          const midpoint = rect.left + rect.width / 2;

          // Determine if we should insert before or after
          if (e.clientX < midpoint) {
            // Insert before this tab
            if (targetTab.previousElementSibling !== draggedTab) {
              tabsContainer.insertBefore(draggedTab, targetTab);
              updateSessionsOrder();
            }
          } else {
            // Insert after this tab
            if (targetTab.nextElementSibling !== draggedTab) {
              tabsContainer.insertBefore(draggedTab, targetTab.nextElementSibling);
              updateSessionsOrder();
            }
          }
        };

        const nameSpan = document.createElement('span');
        nameSpan.className = 'tab-name';
        nameSpan.textContent = session.name;
        tab.appendChild(nameSpan);

        // Show Telegram icon if session is linked to a Telegram group
        if (session.telegram_linked) {
          const telegramIcon = document.createElement('span');
          telegramIcon.className = 'tab-telegram-icon';
          telegramIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>`;
          telegramIcon.title = session.telegram_group_name || 'Linked to Telegram';
          tab.appendChild(telegramIcon);
        }

        // Don't show close button for default session if it's the only one
        if (session.id !== 'default' || sessions.length > 1) {
          const closeBtn = document.createElement('button');
          closeBtn.className = 'tab-close';
          closeBtn.innerHTML = 'Ã—';
          closeBtn.onclick = (e) => {
            e.stopPropagation();
            playNormalClick();
            confirmDeleteSession(session.id, session.name);
          };
          tab.appendChild(closeBtn);
        }

        tabsContainer.insertBefore(tab, newTabBtn);
      });

      // Hide new tab button when at max capacity
      newTabBtn.style.display = sessions.length >= MAX_TABS ? 'none' : '';
    }

    function updateSessionsOrder() {
      // Update sessions array to match current DOM order
      const tabs = tabsContainer.querySelectorAll('.tab');
      const newOrder = [];
      tabs.forEach(tab => {
        const sessionId = tab.dataset.sessionId;
        const session = sessions.find(s => s.id === sessionId);
        if (session) newOrder.push(session);
      });
      sessions = newOrder;
    }

    function confirmDeleteSession(sessionId, sessionName) {
      if (sessions.length <= 1) return;

      if (confirm(`Delete "${sessionName}"? This will remove all messages in this chat.`)) {
        deleteSession(sessionId);
      }
    }

    async function switchSession(sessionId) {
      if (sessionId === currentSessionId) return;

      // Save current session state before switching
      inputTextBySession.set(currentSessionId, input.value);

      // Save search state for current session
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');
      searchTextBySession.set(currentSessionId, searchInput.value);
      searchOpenBySession.set(currentSessionId, searchArea.classList.contains('searching'));

      // Clear search UI (will restore for new session after load)
      searchArea.classList.remove('searching');
      searchInput.value = '';
      clearSearchHighlights();
      searchMatches = [];
      currentSearchIndex = 0;

      // Switch to new session
      currentSessionId = sessionId;
      localStorage.setItem('currentSessionId', currentSessionId);
      ensureStatusListener(sessionId);
      renderTabs();
      messagesDiv.innerHTML = '';
      // Clear stale streaming bubble reference â€” the DOM element was just destroyed.
      // A fresh bubble will be created when partial_text events arrive for this session.
      streamingBubbleBySession.delete(sessionId);
      updateBackgroundTasksUI();
      await loadHistory();

      // Restore pending user messages that haven't been saved to history yet
      const pendingMsgs = pendingUserMessagesBySession.get(sessionId);
      const isLoading = isLoadingBySession.get(sessionId) || false;

      // Remove empty state if we have pending messages or an active query
      if ((pendingMsgs && pendingMsgs.size > 0) || isLoading) {
        const emptyState = messagesDiv.querySelector('.empty-state');
        if (emptyState) emptyState.remove();
      }

      if (pendingMsgs && pendingMsgs.size > 0) {
        pendingMsgs.forEach((msgData, msgId) => {
          const userMsgEl = addMessage('user', msgData.content, true, msgData.attachments);
          userMsgEl.dataset.messageId = msgId;
          // Check if this was a queued message
          const queuedIds = queuedMessageIdsBySession.get(sessionId) || new Set();
          if (queuedIds.has(msgId)) {
            userMsgEl.classList.add('queued');
            queuedMessageElements.set(msgId, userMsgEl);
          }
          // Restore workflow badge
          if (msgData.workflowName) {
            userMsgEl.classList.add('from-workflow');
          }
        });
      }

      updateStats();

      // Restore input text for this session
      input.value = inputTextBySession.get(sessionId) || '';
      // Auto-resize input to match content
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 150) + 'px';

      // Restore ghost suggestion for this session
      const savedSuggestion = getCurrentSuggestion();
      if (savedSuggestion) {
        ghostSuggestion.innerHTML = escapeHtml(savedSuggestion) + '<span class="tab-hint">Tab to accept</span>';
        ghostSuggestion.style.display = 'block';
      } else {
        ghostSuggestion.innerHTML = '';
        ghostSuggestion.style.display = 'none';
      }

      // Restore search state for this session
      const savedSearchText = searchTextBySession.get(sessionId) || '';
      const wasSearchOpen = searchOpenBySession.get(sessionId) || false;
      if (wasSearchOpen || savedSearchText) {
        searchInput.value = savedSearchText;
        if (wasSearchOpen) {
          searchArea.classList.add('searching');
          // Re-run search to highlight matches in new session's messages
          if (savedSearchText) {
            performSearch(savedSearchText);
          }
        }
      }

      // Restore attachment previews for this session
      renderAttachmentPreviews();

      // Update button state based on whether THIS session is loading
      setButtonState(isLoading);

      // Restore status indicator if this session has an active query
      if (isLoading) {
        // Create a new status indicator for this session
        const existingStatusEl = statusElBySession.get(sessionId);
        if (!existingStatusEl || !messagesDiv.contains(existingStatusEl)) {
          const statusEl = addStatusIndicator('*stretches paws* thinking...');
          statusElBySession.set(sessionId, statusEl);
        }
      }

      input.focus();
    }

    function getNextSessionName() {
      const names = new Set(sessions.map(s => s.name));
      if (!names.has('New')) return 'New';
      for (let i = 2; i <= 99; i++) {
        if (!names.has(`New${i}`)) return `New${i}`;
      }
      return `New${Date.now() % 10000}`;
    }

    async function createNewSession() {
      // Check tab limit
      if (sessions.length >= MAX_TABS) {
        return;
      }

      try {
        const result = await window.pocketAgent.createSession(getNextSessionName());
        if (!result.success || !result.session) {
          addMessage('system', result.error || 'Failed to create session');
          return;
        }
        sessions.push(result.session); // Add to end (right side)
        currentSessionId = result.session.id;
        renderTabs();
        messagesDiv.innerHTML = '';
        showEmptyState();
        updateStats();
        input.focus();
        // Start rename immediately
        setTimeout(() => startRenameSession(result.session.id), 100);
      } catch (err) {
        console.error('Failed to create session:', err);
      }
    }

    function startRenameSession(sessionId) {
      const tab = tabsContainer.querySelector(`[data-session-id="${sessionId}"]`);
      if (!tab) return;

      const nameSpan = tab.querySelector('.tab-name');
      const currentName = nameSpan.textContent;

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'tab-name-input';
      input.value = currentName;
      input.maxLength = 10;

      // Sanitize input: single word only (no spaces), max 10 chars
      input.oninput = () => {
        // Remove spaces and limit to 10 chars
        input.value = input.value.replace(/\s/g, '').slice(0, 10);
      };

      input.onblur = () => finishRename(sessionId, input.value);
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.blur();
        } else if (e.key === 'Escape') {
          input.value = currentName;
          input.blur();
        } else if (e.key === ' ') {
          // Prevent space key
          e.preventDefault();
        }
      };

      nameSpan.replaceWith(input);
      input.focus();
      input.select();
    }

    async function finishRename(sessionId, newName) {
      // Sanitize: remove spaces, limit to 10 chars, fallback to 'Untitled'
      const sanitizedName = newName.replace(/\s/g, '').slice(0, 10) || 'Untitled';

      try {
        const result = await window.pocketAgent.renameSession(sessionId, sanitizedName);
        if (!result.success) {
          // Show error (likely duplicate name)
          addMessage('system', result.error || 'Failed to rename session');
          renderTabs(); // Revert UI
          return;
        }
        // Update local state
        const session = sessions.find(s => s.id === sessionId);
        if (session) {
          session.name = sanitizedName;
        }
        renderTabs();
      } catch (err) {
        console.error('Failed to rename session:', err);
        renderTabs(); // Revert UI
      }
    }

    async function deleteSession(sessionId) {
      if (sessions.length <= 1) {
        // Can't delete the last session
        return;
      }

      try {
        // Clean up status listener for this session
        const statusCleanup = statusCleanupBySession.get(sessionId);
        if (statusCleanup) {
          statusCleanup();
          statusCleanupBySession.delete(sessionId);
        }

        // Remove status indicator element
        const statusEl = statusElBySession.get(sessionId);
        if (statusEl) {
          statusEl.remove();
          statusElBySession.delete(sessionId);
        }
        toolCountBySession.delete(sessionId);

        // Clean up loading state
        isLoadingBySession.delete(sessionId);

        // Clean up queued message tracking for this session
        const queuedIds = queuedMessageIdsBySession.get(sessionId);
        if (queuedIds) {
          for (const msgId of queuedIds) {
            queuedMessageElements.delete(msgId);
          }
          queuedMessageIdsBySession.delete(sessionId);
        }

        // Clean up pending user messages
        pendingUserMessagesBySession.delete(sessionId);

        // Now delete the session (this also stops any running query)
        const result = await window.pocketAgent.deleteSession(sessionId);

        if (!result.success) {
          console.error('Failed to delete session from database');
          // Refresh sessions from DB to ensure UI is in sync
          sessions = await window.pocketAgent.getSessions();
          renderTabs();
          return;
        }

        sessions = sessions.filter(s => s.id !== sessionId);

        // If we deleted the current session, switch to another
        if (sessionId === currentSessionId) {
          currentSessionId = sessions[0]?.id || 'default';
          localStorage.setItem('currentSessionId', currentSessionId);
          messagesDiv.innerHTML = '';
          await loadHistory();
        }

        renderTabs();
        updateStats();
      } catch (err) {
        console.error('Failed to delete session:', err);
        // Refresh sessions from DB to ensure UI is in sync
        sessions = await window.pocketAgent.getSessions();
        renderTabs();
      }
    }

    function handleSchedulerMessage(data) {
      console.log(`[Chat] handleSchedulerMessage called - data.sessionId: ${data.sessionId}, currentSessionId: ${currentSessionId}`);
      // Only show message if it's for the current session
      if (data.sessionId && data.sessionId !== currentSessionId) {
        console.log(`[Chat] SKIPPING - session mismatch`);
        return;
      }
      console.log(`[Chat] DISPLAYING - session matches or no sessionId`);

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Add the user prompt with scheduled badge
      if (data.prompt) {
        const promptEl = addMessage('user', data.prompt);
        if (data.jobName) {
          promptEl.classList.add('scheduled');
          promptEl.dataset.badge = data.jobName;
        }
      }

      // Add the agent's response with scheduled badge
      const msgEl = addMessage('assistant', data.response);
      if (data.jobName) {
        msgEl.classList.add('scheduled');
        msgEl.dataset.badge = data.jobName;
      }

      // Update stats and scroll
      updateStats();
      scrollToBottom();

      // Focus window
      window.focus();
    }

    function handleTelegramMessage(data) {
      // Only show message if it's for the current session
      // (messages are already saved to SQLite for the correct session)
      if (data.sessionId && data.sessionId !== currentSessionId) {
        console.log(`[Chat] Telegram message for session ${data.sessionId}, current is ${currentSessionId} - skipping display`);
        return;
      }

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Add Telegram indicator + user message
      addTelegramMessage('user', data.userMessage, data.hasAttachment, data.attachmentType);

      // Add the agent's response (with media if present)
      addMessage('assistant', data.response, true, [], null, true, data.media);

      // Show compaction notice if conversation was compacted
      if (data.wasCompacted) {
        addMessage('system', 'your chat has been compacted', true, [], null, false);
      }

      // Update stats and scroll
      updateStats();
      scrollToBottom();
    }

    // Helper to get appropriate label for attachment type
    function getAttachmentLabel(hasAttachment, attachmentType) {
      if (!hasAttachment) return '';
      switch (attachmentType) {
        case 'photo': return ' ðŸ“·';
        case 'voice': return ' Voice note';
        case 'audio': return ' ðŸŽµ';
        default: return ' ðŸ“Ž';
      }
    }

    function addTelegramMessage(role, content, hasAttachment = false, attachmentType = null) {
      const wrapper = document.createElement('div');
      wrapper.className = `message ${role} from-telegram`;

      // Get attachment icon based on type
      const attachmentLabel = getAttachmentLabel(hasAttachment, attachmentType);

      // Telegram badge with icon
      const badge = document.createElement('div');
      badge.className = 'telegram-badge';
      badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>${attachmentLabel}`;
      wrapper.appendChild(badge);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = formatContent(content);
      // Intercept link clicks to open in external browser
      contentDiv.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (link) {
          e.preventDefault();
          const href = link.getAttribute('href');
          if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
            window.pocketAgent.openExternal(href);
          }
        }
      });
      wrapper.appendChild(contentDiv);

      // Add timestamp
      const timestampDiv = document.createElement('div');
      timestampDiv.className = 'message-timestamp';
      timestampDiv.textContent = formatTimestamp(new Date());
      wrapper.appendChild(timestampDiv);

      messagesDiv.appendChild(wrapper);
      return wrapper;
    }

    function handleIOSMessage(data) {
      // Only show message if it's for the current session
      if (data.sessionId && data.sessionId !== currentSessionId) {
        console.log(`[Chat] iOS message for session ${data.sessionId}, current is ${currentSessionId} - skipping display`);
        return;
      }

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Add iOS indicator + user message (strip workflow content for display)
      let iosDisplayMsg = data.userMessage;
      if (iosDisplayMsg && iosDisplayMsg.startsWith('[Workflow: ')) {
        const eb = iosDisplayMsg.indexOf(']');
        const em = iosDisplayMsg.indexOf('[/Workflow]');
        if (eb !== -1 && em !== -1) {
          const wfName = iosDisplayMsg.substring(11, eb);
          const userText = iosDisplayMsg.substring(em + 11).replace(/^\n\n/, '').trim();
          iosDisplayMsg = wfName + (userText ? ' ' + userText : '');
        }
      }
      addIOSMessage('user', iosDisplayMsg);

      // Add the agent's response (with media if present) â€” skip empty (aborted)
      if (data.response) {
        addMessage('assistant', data.response, true, [], null, true, data.media);
      }

      // Update stats and scroll
      updateStats();
      scrollToBottom();
    }

    function addIOSMessage(role, content) {
      const wrapper = document.createElement('div');
      wrapper.className = `message ${role} from-ios`;

      // iOS badge with phone icon
      const badge = document.createElement('div');
      badge.className = 'ios-badge';
      badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg> Mobile`;
      wrapper.appendChild(badge);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = formatContent(content);
      contentDiv.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (link) {
          e.preventDefault();
          const href = link.getAttribute('href');
          if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
            window.pocketAgent.openExternal(href);
          }
        }
      });
      wrapper.appendChild(contentDiv);

      const timestampDiv = document.createElement('div');
      timestampDiv.className = 'message-timestamp';
      timestampDiv.textContent = formatTimestamp(new Date());
      wrapper.appendChild(timestampDiv);

      messagesDiv.appendChild(wrapper);
      return wrapper;
    }

    async function loadHistory() {
      try {
        const history = await window.pocketAgent.getHistory(100, currentSessionId);
        messagesDiv.innerHTML = '';

        if (history.length === 0) {
          showEmptyState();
        } else {
          let lastDate = null;
          for (let i = 0; i < history.length; i++) {
            const msg = history[i];
            // Add date separator if needed
            const msgDate = parseSqliteTimestamp(msg.timestamp).toLocaleDateString();
            if (msgDate !== lastDate) {
              addTimestamp(msgDate);
              lastDate = msgDate;
            }

            // Strip workflow content from user messages â€” show badge + user text only
            let displayContent = msg.content;
            let isWorkflowMsg = false;
            if (msg.role === 'user' && msg.content.startsWith('[Workflow: ')) {
              const endBracket = msg.content.indexOf(']');
              const endMarker = msg.content.indexOf('[/Workflow]');
              if (endBracket !== -1 && endMarker !== -1) {
                const workflowName = msg.content.substring(11, endBracket);
                const userText = msg.content.substring(endMarker + 11).replace(/^\n\n/, '').trim();
                displayContent = workflowName + (userText ? ' ' + userText : '');
                isWorkflowMsg = true;
              }
            }

            // Render error messages with error style instead of assistant style
            const renderRole = (msg.role === 'assistant' && msg.metadata?.isError) ? 'error' : msg.role;
            const msgEl = addMessage(renderRole, displayContent, false, [], msg.timestamp);
            // Add workflow badge
            if (isWorkflowMsg) {
              msgEl.classList.add('from-workflow');
            }
            // Add scheduled badge if message came from scheduler
            if (msg.metadata?.source === 'scheduler' && msg.metadata?.jobName) {
              msgEl.classList.add('scheduled');
              msgEl.dataset.badge = msg.metadata.jobName;
            }
            // Add Telegram badge if message came from Telegram
            if (msg.metadata?.source === 'telegram') {
              msgEl.classList.add('from-telegram');
              const badge = document.createElement('div');
              badge.className = 'telegram-badge';
              const attachmentLabel = getAttachmentLabel(msg.metadata.hasAttachment, msg.metadata.attachmentType);
              badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>${attachmentLabel}`;
              msgEl.insertBefore(badge, msgEl.firstChild);
            }
            // Add iOS badge if message came from mobile
            if (msg.metadata?.source === 'ios') {
              msgEl.classList.add('from-ios');
              const badge = document.createElement('div');
              badge.className = 'ios-badge';
              badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg> Mobile`;
              msgEl.insertBefore(badge, msgEl.firstChild);
            }
          }
        }

        scrollToBottom(true); // Instant scroll on initial load
      } catch (err) {
        console.error('Failed to load history:', err);
        showEmptyState();
      }
    }

    async function updateStats() {
      try {
        const stats = await window.pocketAgent.getStats(currentSessionId);
        if (stats) {
          const formatTokens = (n) => n >= 1000 ? `${(n / 1000).toFixed(1)}k` : String(n);

          let parts = [`${stats.messageCount} msgs`, `${stats.factCount} facts`];
          if (stats.contextTokens != null && stats.contextWindow) {
            parts.push(`${formatTokens(stats.contextTokens)} / ${formatTokens(stats.contextWindow)} context`);
          }

          statsDiv.textContent = parts.join(' Â· ');
        }
      } catch (err) {
        console.error('Failed to get stats:', err);
      }
    }

    async function updateModelBadge() {
      try {
        const badge = document.getElementById('model-badge');
        const modelId = await window.pocketAgent.getSetting('agent.model');
        const fallbackNames = {
          'claude-opus-4-6': 'OPUS 4.6',
          'claude-sonnet-4-6': 'SONNET 4.6',
          'claude-haiku-4-5-20251001': 'HAIKU 4.5',
          'kimi-k2.5': 'KIMI K2.5',
          'glm-5': 'GLM-5',
          'glm-4.7': 'GLM-4.7',
        };

        let models = [];
        try {
          models = await window.pocketAgent.getAvailableModels();
        } catch (_) {
          // IPC failed â€” fall back to single option
        }

        badge.innerHTML = '';

        if (models.length > 0) {
          for (const model of models) {
            const opt = document.createElement('option');
            opt.value = model.id;
            opt.textContent = model.name;
            if (model.id === modelId) opt.selected = true;
            badge.appendChild(opt);
          }
        } else {
          // Fallback: show current model only
          const opt = document.createElement('option');
          opt.value = modelId;
          opt.textContent = fallbackNames[modelId] || modelId.toUpperCase();
          opt.selected = true;
          badge.appendChild(opt);
        }
      } catch (err) {
        console.error('Failed to load model:', err);
      }
    }

    // Model badge change handler â€” switch model and auto-reboot
    document.getElementById('model-badge').addEventListener('change', async (e) => {
      const newModel = e.target.value;
      const badge = e.target;
      try {
        // Save new model setting
        await window.pocketAgent.setSetting('agent.model', newModel);
        // Flash badge to indicate switching
        badge.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
        // Restart agent with new model
        await window.pocketAgent.restartAgent();
        // Restore badge color
        badge.style.background = '';
        await updateModelBadge();
      } catch (err) {
        console.error('Failed to switch model:', err);
        badge.style.background = '';
        await updateModelBadge();
      }
    });

    function handleSendClick() {
      playSendClick();
      if (globalChatMode) {
        sendGlobalChatMessage();
        return;
      }
      if (isLoadingBySession.get(currentSessionId)) {
        stopQuery();
      } else {
        sendMessage();
      }
    }

    function setButtonState(loading) {
      if (globalChatMode) return;
      const sendIcon = sendBtn.querySelector('.send-icon');
      const stopIcon = sendBtn.querySelector('.stop-icon');

      if (loading) {
        sendBtn.classList.add('stop-btn');
        sendBtn.title = 'Stop it!';
        sendIcon.style.display = 'none';
        stopIcon.style.display = 'block';
        sendBtn.disabled = false;
      } else {
        sendBtn.classList.remove('stop-btn');
        sendBtn.title = 'Send it!';
        sendIcon.style.display = 'block';
        stopIcon.style.display = 'none';
      }
    }

    async function stopQuery() {
      const sessionId = currentSessionId;
      try {
        await window.pocketAgent.stop(sessionId);

        // Clean up status listener for this session
        const statusCleanup = statusCleanupBySession.get(sessionId);
        if (statusCleanup) {
          statusCleanup();
          statusCleanupBySession.delete(sessionId);
        }

        // Remove status indicator for this session
        const statusEl = statusElBySession.get(sessionId);
        if (statusEl) {
          statusEl.remove();
          statusElBySession.delete(sessionId);
        }
        toolCountBySession.delete(sessionId);

        // Remove 'queued' class from any queued messages and clear tracking
        const queuedMsgs = messagesDiv.querySelectorAll('.message.queued');
        queuedMsgs.forEach(msg => msg.classList.remove('queued'));
        queuedMessageElements.clear();

        addMessage('system', 'query stopped', true, [], null, false);

        isLoadingBySession.set(sessionId, false);
        renderTabs(); // Update tab loading indicator
        setButtonState(false);
        scrollToBottom();
        input.focus();
      } catch (err) {
        console.error('Failed to stop query:', err);
      }
    }

    async function sendMessage() {
      const message = input.value.trim();
      const attachments = [...getPendingAttachments()];
      const sessionId = currentSessionId; // Capture session at start
      const workflow = activeWorkflow; // Capture active workflow

      if (!message && attachments.length === 0 && !workflow) return;

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Check if already processing - if so, message will be queued
      const isQueued = isLoadingBySession.get(sessionId);
      const messageId = `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;

      // Always clear input immediately for responsive UX
      input.value = '';
      input.style.height = 'auto';
      clearSuggestion();
      clearAttachments();
      if (workflow) clearWorkflow();

      // Show user message - mark as queued if there's already a message processing
      const displayMessage = workflow ? `${workflow.name}${message ? ' ' + message : ''}` : message;
      const userMsgEl = addMessage('user', displayMessage, true, attachments);
      userMsgEl.dataset.messageId = messageId;
      if (workflow) {
        userMsgEl.classList.add('from-workflow');
      }

      // Track pending user message for session state restoration
      if (!pendingUserMessagesBySession.has(sessionId)) {
        pendingUserMessagesBySession.set(sessionId, new Map());
      }
      pendingUserMessagesBySession.get(sessionId).set(messageId, { content: displayMessage, attachments: attachments, workflowName: workflow?.name || null });

      if (isQueued) {
        userMsgEl.classList.add('queued');
        userMsgEl.dataset.messageId = messageId;
        queuedMessageElements.set(messageId, userMsgEl);
        // Track queued message ID for session state restoration
        if (!queuedMessageIdsBySession.has(sessionId)) {
          queuedMessageIdsBySession.set(sessionId, new Set());
        }
        queuedMessageIdsBySession.get(sessionId).add(messageId);
      }

      // If not already processing, show status indicator and set loading state
      if (!isQueued) {
        isLoadingBySession.set(sessionId, true);
        renderTabs();
        setButtonState(true);
        const statusEl = addStatusIndicator('*stretches paws* thinking...');
        statusElBySession.set(sessionId, statusEl);
      }

      scrollToBottom();

      // Build the full message with attachments and workflow
      let fullMessage = await buildMessageWithAttachments(message, attachments);
      if (workflow) {
        const workflowPrefix = `[Workflow: ${workflow.name}]\n${workflow.content}\n[/Workflow]`;
        fullMessage = fullMessage ? `${workflowPrefix}\n\n${fullMessage}` : workflowPrefix;
      }

      // Set up status listener for this session (only if not already set up)
      ensureStatusListener(sessionId);

      try {
        // This will resolve when the message is actually processed (not when queued)
        const result = await window.pocketAgent.send(fullMessage, sessionId);

        // If this message was queued, remove the queued state
        if (queuedMessageElements.has(messageId)) {
          const msgEl = queuedMessageElements.get(messageId);
          if (msgEl) {
            msgEl.classList.remove('queued');
          }
          queuedMessageElements.delete(messageId);
          // Remove from session tracking
          const queuedIds = queuedMessageIdsBySession.get(sessionId);
          if (queuedIds) queuedIds.delete(messageId);
        }

        // Remove from pending user messages (message is now saved to history)
        const pendingMsgs = pendingUserMessagesBySession.get(sessionId);
        if (pendingMsgs) pendingMsgs.delete(messageId);

        // Clean up loading state regardless of which tab is active
        // (otherwise indicators persist if user switched tabs mid-query)
        const hasMoreQueued = queuedMessageElements.size > 0;

        if (!hasMoreQueued) {
          // Clean up status listener
          const cleanup = statusCleanupBySession.get(sessionId);
          if (cleanup) {
            cleanup();
            statusCleanupBySession.delete(sessionId);
          }

          // Remove status indicator
          const currentStatusEl = statusElBySession.get(sessionId);
          if (currentStatusEl) {
            currentStatusEl.remove();
            statusElBySession.delete(sessionId);
          }
          toolCountBySession.delete(sessionId);

          isLoadingBySession.set(sessionId, false);
          renderTabs();
          if (currentSessionId === sessionId) {
            setButtonState(false);
          }
        }

        // Always clean up streaming bubble reference (may be stale if user switched sessions)
        const streamBubble = streamingBubbleBySession.get(sessionId);
        if (streamBubble) {
          streamBubble.remove();
          streamingBubbleBySession.delete(sessionId);
        }

        // Only update visible UI if still on same session
        if (currentSessionId === sessionId) {
          if (result.stopped) {
            // Query was stopped â€” nothing to display
          } else if (result.success) {
            addMessage('assistant', result.response, true, [], null, true, result.media);

            // Show compaction notice if conversation was compacted
            if (result.wasCompacted) {
              addMessage('system', 'your chat has been compacted', true, [], null, false);
            }

            // If there's a suggested prompt, show it as ghost text
            if (result.suggestedPrompt) {
              setSuggestion(result.suggestedPrompt);
            }
          } else {
            // Don't show stop/abort related errors - they're already handled
            const errorMsg = result.error || '';
            if (!errorMsg.includes('stopped') && !errorMsg.includes('aborted') && !errorMsg.includes('Aborted')) {
              addMessage('error', errorMsg);
            }
          }

          updateStats();
          scrollToBottom();
        }
      } catch (err) {
        // If this message was queued, remove the queued state
        if (queuedMessageElements.has(messageId)) {
          const msgEl = queuedMessageElements.get(messageId);
          if (msgEl) {
            msgEl.classList.remove('queued');
          }
          queuedMessageElements.delete(messageId);
          // Remove from session tracking
          const queuedIds = queuedMessageIdsBySession.get(sessionId);
          if (queuedIds) queuedIds.delete(messageId);
        }

        // Remove from pending user messages (message is now saved to history)
        const pendingMsgsErr = pendingUserMessagesBySession.get(sessionId);
        if (pendingMsgsErr) pendingMsgsErr.delete(messageId);

        // Check if there are more queued messages
        const hasMoreQueued = queuedMessageElements.size > 0;

        if (!hasMoreQueued) {
          // Clean up status listener
          const cleanup = statusCleanupBySession.get(sessionId);
          if (cleanup) {
            cleanup();
            statusCleanupBySession.delete(sessionId);
          }

          const currentStatusEl = statusElBySession.get(sessionId);
          if (currentStatusEl) {
            currentStatusEl.remove();
            statusElBySession.delete(sessionId);
          }
          toolCountBySession.delete(sessionId);

          isLoadingBySession.set(sessionId, false);
          renderTabs();
          setButtonState(false);
        }

        // Only show error if still on same session and not stopped/cleared/aborted
        if (currentSessionId === sessionId && !err.message?.includes('stopped') && !err.message?.includes('cleared') && !err.message?.includes('aborted') && !err.message?.includes('Aborted')) {
          addMessage('error', err.message || 'Something went wrong');
        }

        scrollToBottom();
      }

      input.focus();
    }

    async function buildMessageWithAttachments(message, attachments) {
      if (attachments.length === 0) return message;

      const parts = [];

      // Add text message if present
      if (message) {
        parts.push(message);
      }

      // Add attachments
      for (const att of attachments) {
        if (att.isImage && att.dataUrl) {
          // Save image to temp file and reference path
          try {
            const filePath = await window.pocketAgent.saveAttachment(att.name, att.dataUrl);
            parts.push(`\n\n[Attached image: ${att.name}]\nFile saved at: ${filePath}\nUse the Read tool to view this image.`);
          } catch (err) {
            parts.push(`\n\n[Image: ${att.name}] (failed to save: ${err.message})`);
          }
        } else if (EXTRACTABLE_EXTENSIONS.has(att.ext) && att.dataUrl) {
          // Save Office document, extract text, and include inline
          try {
            const filePath = await window.pocketAgent.saveAttachment(att.name, att.dataUrl);
            try {
              const text = await window.pocketAgent.extractText(filePath);
              const content = text.length > 50000 ? text.slice(0, 50000) + '\n... (truncated)' : text;
              parts.push(`\n\n[Attached document: ${att.name}]\nFile saved at: ${filePath}\n\n\`\`\`\n${content}\n\`\`\``);
            } catch {
              parts.push(`\n\n[Attached document: ${att.name}]\nFile saved at: ${filePath}\nUse the Read tool to view this document.`);
            }
          } catch (err) {
            parts.push(`\n\n[Document: ${att.name}] (failed to save: ${err.message})`);
          }
        } else if (BINARY_EXTENSIONS.has(att.ext) && att.dataUrl) {
          // Save binary document to temp file and reference path
          try {
            const filePath = await window.pocketAgent.saveAttachment(att.name, att.dataUrl);
            parts.push(`\n\n[Attached document: ${att.name}]\nFile saved at: ${filePath}\nUse the Read tool to view this document.`);
          } catch (err) {
            parts.push(`\n\n[Document: ${att.name}] (failed to save: ${err.message})`);
          }
        } else if (att.content) {
          // For text files, include content directly (truncate if very large)
          const content = att.content.length > 50000
            ? att.content.slice(0, 50000) + '\n... (truncated)'
            : att.content;
          parts.push(`\n\n[File: ${att.name}]\n\`\`\`${att.ext}\n${content}\n\`\`\``);
        }
      }

      return parts.join('');
    }

    async function clearChat() {
      if (!confirm('Start fresh? Don\'t worry - I\'ll keep everything I know about you!')) return;

      try {
        await window.pocketAgent.clearConversation(currentSessionId);
        messagesDiv.innerHTML = '';
        showEmptyState();
        updateStats();
      } catch (err) {
        addMessage('error', err.message);
      }
    }

    async function showFacts() {
      try {
        await window.pocketAgent.openFacts();
      } catch (err) {
        console.error('Failed to open facts:', err);
      }
    }

    async function showDailyLogs() {
      try {
        await window.pocketAgent.openDailyLogs();
      } catch (err) {
        console.error('Failed to open daily logs:', err);
      }
    }

    async function showSoul() {
      try {
        await window.pocketAgent.openSoul();
      } catch (err) {
        console.error('Failed to open soul:', err);
      }
    }

    function addMessage(role, content, animate = true, attachments = [], timestamp = null, showTimestamp = true, media = null) {
      const div = document.createElement('div');
      div.className = `message ${role}`;
      if (!animate) div.style.animation = 'none';

      // Add attachments display for user messages
      if (attachments && attachments.length > 0) {
        const attDiv = document.createElement('div');
        attDiv.className = 'message-attachments';

        for (const att of attachments) {
          const attItem = document.createElement('div');
          attItem.className = 'message-attachment';

          if (att.isImage && att.dataUrl) {
            const img = document.createElement('img');
            img.src = att.dataUrl;
            img.alt = att.name;
            attItem.appendChild(img);
          } else {
            attItem.innerHTML = `<span class="attachment-icon">${escapeHtml(att.ext)}</span> ${escapeHtml(att.name)}`;
          }

          attDiv.appendChild(attItem);
        }

        div.appendChild(attDiv);
      }

      // Add text content
      if (content) {
        const contentDiv = document.createElement('div');
        // Format error messages with structured layout
        if (role === 'error') {
          contentDiv.innerHTML = formatErrorContent(content);
        } else {
          contentDiv.innerHTML = formatContent(content);
        }
        // Append children directly to avoid nesting issues
        while (contentDiv.firstChild) {
          div.appendChild(contentDiv.firstChild);
        }
        // Intercept link and image clicks
        div.addEventListener('click', (e) => {
          // Open links in external browser
          const link = e.target.closest('a[href]');
          if (link) {
            e.preventDefault();
            const href = link.getAttribute('href');
            if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
              window.pocketAgent.openExternal(href);
            }
            return;
          }
          // Open markdown-rendered images in default image viewer
          if (e.target.tagName === 'IMG' && !e.target.closest('.message-media')) {
            const src = e.target.getAttribute('src');
            if (src) {
              window.pocketAgent.openImage(src);
            }
            return;
          }
          // Open attached files from history
          const attEl = e.target.closest('.message-attachment[data-path]');
          if (attEl) {
            window.pocketAgent.openPath(attEl.dataset.path);
          }
        });
      }

      // Add response media images (from agent screenshots/tools)
      if (media && media.length > 0) {
        const mediaDiv = document.createElement('div');
        mediaDiv.className = 'message-media';

        for (const item of media) {
          if (item.type === 'image') {
            const img = document.createElement('img');
            img.alt = 'Agent image';
            img.loading = 'lazy';

            // If it's already a data URI, use directly; otherwise load via IPC
            if (item.dataUri) {
              img.src = item.dataUri;
            } else if (item.filePath) {
              // Load image via IPC to get data URI
              window.pocketAgent.readMedia(item.filePath).then(dataUri => {
                if (dataUri) {
                  img.src = dataUri;
                }
              });
            }

            // Click to open in default image viewer
            if (item.filePath) {
              img.title = 'Click to open';
              img.addEventListener('click', () => {
                window.pocketAgent.openImage(item.filePath);
              });
            }

            mediaDiv.appendChild(img);
          }
        }

        div.appendChild(mediaDiv);
      }

      // Add footer with copy button and timestamp
      if (showTimestamp) {
        const ts = timestamp ? parseSqliteTimestamp(timestamp) : new Date();
        const footerDiv = document.createElement('div');
        footerDiv.className = 'message-footer';

        // Copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'message-copy-btn';
        copyBtn.title = 'Copy';
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>`;
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          copyMessageText(div, copyBtn);
        };
        footerDiv.appendChild(copyBtn);

        // Timestamp
        const timestampDiv = document.createElement('div');
        timestampDiv.className = 'message-timestamp';
        timestampDiv.textContent = formatTimestamp(ts);
        footerDiv.appendChild(timestampDiv);

        div.appendChild(footerDiv);
      }

      // Insert before status indicator if one exists (keeps indicator at bottom)
      const statusIndicator = messagesDiv.querySelector('.status-indicator');
      if (statusIndicator) {
        messagesDiv.insertBefore(div, statusIndicator);
      } else {
        messagesDiv.appendChild(div);
      }
      return div;
    }

    // Parse SQLite timestamp consistently (SQLite stores UTC with 'Z' suffix)
    function parseSqliteTimestamp(timestamp) {
      if (!timestamp) return new Date();

      // Check if timestamp has an explicit timezone indicator (Z, +HH:MM, -HH:MM, +HHMM, -HHMM)
      const hasTimezone = /Z$|[+-]\d{2}:?\d{2}$/.test(timestamp);

      if (hasTimezone) {
        // Already has timezone info, parse directly
        return new Date(timestamp);
      }

      // Legacy fallback: old timestamps without timezone (assumed UTC)
      const normalized = timestamp.replace(' ', 'T');
      return new Date(normalized + 'Z');
    }

    function formatTimestamp(date) {
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();

      const timeStr = date.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });

      if (isToday) {
        return `Today, ${timeStr}`;
      }

      const dateStr = date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric'
      });

      return `${dateStr}, ${timeStr}`;
    }

    function formatErrorContent(text) {
      const escaped = escapeHtml(text);
      // Separate report hint if present
      const reportHint = 'If this keeps happening, send this error to the developer.';
      const hasReportHint = escaped.includes(reportHint);
      const mainText = hasReportHint ? escaped.split(reportHint)[0].trim() : escaped;

      // Extract error code if present: [error_code]
      const codeMatch = mainText.match(/\[([a-z_]+)\]/);
      const errorCode = codeMatch ? codeMatch[1] : null;
      const body = codeMatch ? mainText.replace(/\s*\[[a-z_]+\]/, '').trim() : mainText;

      let html = '<div class="error-label">error</div>';
      html += `<div class="error-body">${body}</div>`;
      if (errorCode) {
        html += `<div class="error-code">${errorCode}</div>`;
      }
      if (hasReportHint) {
        html += `<div class="error-report">${reportHint}</div>`;
      }
      return html;
    }

    function formatContent(text) {
      // Pre-process: convert attachment markers into styled chips before markdown
      // Handles: [Attached document: name], [Attached PDF: name], [Attached image: name], etc.
      // Also strips trailing extracted content code block if present
      text = text.replace(
        /\[Attached [^\]]*?: ([^\]]+)\]\nFile saved at: ([^\n]+)\n(?:Use the Read tool to view this [^\n]*\.)?(?:\n*```[\s\S]*?```)?/g,
        (_, name, filePath) => {
          const ext = name.split('.').pop()?.toLowerCase() || '';
          const safeExt = ext.replace(/[<>&"']/g, '');
          const safeName = name.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
          const safePath = filePath.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
          return `\n<div class="message-attachment" data-path="${safePath}" style="cursor:pointer" title="${safePath}"><span class="attachment-icon">${safeExt}</span> ${safeName}</div>\n`;
        }
      );
      // Handle legacy [File: name] format (old extracted documents stored without path)
      // Also strips the code block that follows
      text = text.replace(
        /\[File: ([^\]]+\.(?:docx|pptx|xlsx|odt|odp|ods|rtf))\]\n(?:```[\s\S]*?```)?/gi,
        (_, name) => {
          const ext = name.split('.').pop()?.toLowerCase() || '';
          const safeExt = ext.replace(/[<>&"']/g, '');
          const safeName = name.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
          return `<div class="message-attachment"><span class="attachment-icon">${safeExt}</span> ${safeName}</div>\n`;
        }
      );

      // Use marked for full markdown rendering
      if (typeof marked !== 'undefined') {
        marked.setOptions({
          breaks: true, // Convert \n to <br>
          gfm: true, // GitHub flavored markdown
        });
        let html = marked.parse(text);
        // Wrap tables in scrollable container
        html = html.replace(/<table>/g, '<div class="table-wrapper"><table>');
        html = html.replace(/<\/table>/g, '</table></div>');
        // Sanitize to prevent XSS from untrusted message sources (Telegram, iOS, agent responses)
        if (typeof DOMPurify !== 'undefined') {
          html = DOMPurify.sanitize(html, {
            ADD_ATTR: ['data-path', 'target'],
          });
        }
        return html;
      }
      // Fallback if marked isn't loaded
      return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function addTimestamp(date) {
      const div = document.createElement('div');
      div.className = 'timestamp';
      div.textContent = date;
      messagesDiv.appendChild(div);
    }

    function addTyping() {
      const div = document.createElement('div');
      div.className = 'typing';
      div.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
      messagesDiv.appendChild(div);
      return div;
    }

    function addStatusIndicator(initialMessage) {
      const div = document.createElement('div');
      div.className = 'status-indicator';
      div.innerHTML = `
        <div class="status-spinner"></div>
        <div class="status-content">
          <div class="status-action">${escapeHtml(initialMessage)}</div>
          <div class="status-detail"></div>
          <div class="status-preview"></div>
        </div>
        <div class="status-count" style="display:none"></div>
      `;
      messagesDiv.appendChild(div);
      return div;
    }

    function updateStatusIndicator(status, sessionId) {
      // Use sessionId if provided, otherwise fall back to current session
      const targetSession = sessionId || currentSessionId;

      // Allow notification sound for any session completing (even non-active)
      if (status.type === 'done' && targetSession !== currentSessionId) {
        playNotificationSound();
        return;
      }

      // GUARD: Never render status/streaming UI for a session that isn't currently displayed.
      // Without this, partial_text bubbles and status updates from session A would be
      // appended to session B's visible messagesDiv when the user switches mid-query.
      if (targetSession !== currentSessionId) return;

      // Handle background tasks before status element check â€” they use a separate UI area
      if (status.type === 'background_task_start') {
        if (status.backgroundTaskId) {
          addBackgroundTask(
            status.sessionId || targetSession,
            status.backgroundTaskId,
            status.toolName || 'task',
            status.backgroundTaskDescription || 'background task'
          );
        }
        return;
      } else if (status.type === 'background_task_output') {
        return;
      } else if (status.type === 'background_task_end') {
        if (status.backgroundTaskId) {
          removeBackgroundTask(status.sessionId || targetSession, status.backgroundTaskId);
        }
        return;
      }

      const statusEl = statusElBySession.get(targetSession);
      if (!statusEl) return;

      const actionEl = statusEl.querySelector('.status-action');
      const detailEl = statusEl.querySelector('.status-detail');
      const previewEl = statusEl.querySelector('.status-preview');
      const countEl = statusEl.querySelector('.status-count');

      // Clear preview when switching to a non-preview status
      if (status.type !== 'partial_text' && previewEl) {
        previewEl.textContent = '';
        previewEl.style.display = 'none';
      }

      if (status.type === 'thinking') {
        // Don't overwrite blocked state
        if (!statusEl.classList.contains('tool-blocked')) {
          actionEl.textContent = status.message || '*stretches paws* thinking...';
          detailEl.textContent = '';
          detailEl.style.display = 'none';
          statusEl.classList.remove('subagent-active');
          statusEl.classList.remove('pocket-cli-active');
          statusEl.classList.remove('team-active');
        }
      } else if (status.type === 'tool_start') {
        // Increment tool call counter
        const count = (toolCountBySession.get(targetSession) || 0) + 1;
        toolCountBySession.set(targetSession, count);
        if (countEl) {
          countEl.textContent = count === 1 ? '1 tool' : `${count} tools`;
          countEl.style.display = '';
        }

        actionEl.textContent = status.toolName || 'pouncing on it...';
        if (status.toolInput) {
          detailEl.textContent = status.toolInput;
          detailEl.title = status.toolInput;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('team-active');
        if (status.isPocketCli) {
          statusEl.classList.add('pocket-cli-active');
        } else {
          statusEl.classList.remove('pocket-cli-active');
        }
      } else if (status.type === 'tool_end') {
        // Don't overwrite blocked state - keep showing the block message
        if (!statusEl.classList.contains('tool-blocked')) {
          actionEl.textContent = status.message || 'caught it! processing...';
          detailEl.textContent = '';
          detailEl.style.display = 'none';
          statusEl.classList.remove('subagent-active');
          statusEl.classList.remove('pocket-cli-active');
          statusEl.classList.remove('team-active');
        }
      } else if (status.type === 'tool_blocked') {
        // Safety hook blocked a dangerous command
        statusEl.classList.add('tool-blocked');
        actionEl.textContent = status.message || 'ðŸ™€ whoa! not allowed!';
        if (status.blockedReason) {
          detailEl.textContent = status.blockedReason;
          detailEl.title = status.blockedReason;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        statusEl.classList.remove('team-active');
      } else if (status.type === 'subagent_start') {
        // Subagent spawned - show special status
        statusEl.classList.add('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        actionEl.textContent = status.message || 'summoning cat friends';
        if (status.toolInput) {
          const countBadge = status.agentCount > 1 ? ` (${status.agentCount} active)` : '';
          detailEl.textContent = status.toolInput + countBadge;
          detailEl.title = status.toolInput;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = status.agentCount > 1 ? `${status.agentCount} helpers active` : '';
          detailEl.style.display = status.agentCount > 1 ? 'block' : 'none';
        }
      } else if (status.type === 'subagent_update') {
        // Multiple subagents, one finished
        actionEl.textContent = status.message || `${status.agentCount} kitties on the job`;
        detailEl.textContent = '';
        detailEl.style.display = 'none';
      } else if (status.type === 'subagent_end') {
        // All subagents done
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        statusEl.classList.remove('team-active');
        actionEl.textContent = status.message || 'cat squad finished! âœ¨';
        detailEl.textContent = '';
        detailEl.style.display = 'none';
      } else if (status.type === 'teammate_start') {
        // Teammate spawned - show team status
        statusEl.classList.add('team-active');
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        actionEl.textContent = status.message || 'rallying the squad';
        if (status.teammateName) {
          detailEl.textContent = status.teammateName + (status.toolInput ? ': ' + status.toolInput : '');
          detailEl.title = detailEl.textContent;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
      } else if (status.type === 'teammate_message') {
        // Message sent between teammates
        statusEl.classList.add('team-active');
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        actionEl.textContent = status.message || 'passing a note';
        if (status.toolInput) {
          detailEl.textContent = status.toolInput;
          detailEl.title = status.toolInput;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
      } else if (status.type === 'teammate_idle') {
        // Teammate went idle
        statusEl.classList.add('team-active');
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        actionEl.textContent = status.message || 'teammate idle';
        if (status.teammateName) {
          detailEl.textContent = status.teammateName + ' finished their part';
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
      } else if (status.type === 'task_completed') {
        // Team task completed
        statusEl.classList.add('team-active');
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        actionEl.textContent = status.message || 'task done!';
        if (status.taskSubject) {
          const by = status.teammateName ? ` (by ${status.teammateName})` : '';
          detailEl.textContent = status.taskSubject + by;
          detailEl.title = detailEl.textContent;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
      } else if (status.type === 'partial_text') {
        // Show live-updating assistant bubble with composed text
        if (status.partialText && status.sessionId) {
          let bubble = streamingBubbleBySession.get(status.sessionId);
          if (!bubble) {
            bubble = document.createElement('div');
            bubble.className = 'message assistant streaming-bubble';
            // Insert before the status indicator
            if (statusEl && statusEl.parentNode) {
              statusEl.parentNode.insertBefore(bubble, statusEl);
            } else {
              messagesDiv.appendChild(bubble);
            }
            streamingBubbleBySession.set(status.sessionId, bubble);
          }
          // Accumulate partial text (each event has one message's text)
          const prev = bubble.dataset.accumulatedText || '';
          const accumulated = prev ? prev + '\n\n' + status.partialText : status.partialText;
          bubble.dataset.accumulatedText = accumulated;
          // Re-render all accumulated text
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = formatContent(accumulated);
          bubble.innerHTML = '';
          while (contentDiv.firstChild) {
            bubble.appendChild(contentDiv.firstChild);
          }
          scrollToBottom();
        }
      } else if (status.type === 'responding') {
        actionEl.textContent = 'grooming my response... ðŸˆ';
        detailEl.textContent = '';
        detailEl.style.display = 'none';
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        statusEl.classList.remove('team-active');
      } else if (status.type === 'queued') {
        // Message was queued - show queue position
        actionEl.textContent = status.message || 'in the litter queue ðŸ“‹';
        if (status.queuePosition) {
          detailEl.textContent = `Position #${status.queuePosition} in queue`;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        statusEl.classList.remove('team-active');
      } else if (status.type === 'queue_processing') {
        // Now processing a queued message
        actionEl.textContent = status.message || 'digging it up now...';
        if (status.queuedMessage) {
          detailEl.textContent = status.queuedMessage;
          detailEl.title = status.queuedMessage;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
        statusEl.classList.remove('pocket-cli-active');
        statusEl.classList.remove('team-active');

        // Remove 'queued' class from the oldest queued message since it's now processing
        const queuedMsgs = messagesDiv.querySelectorAll('.message.queued');
        if (queuedMsgs.length > 0) {
          queuedMsgs[0].classList.remove('queued');
        }
      } else if (status.type === 'done') {
        // Don't touch streaming bubble here â€” response handler finalizes it
        // Response complete - play notification sound
        playNotificationSound();
      }

      scrollToBottom();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function copyMessageText(messageEl, copyBtn) {
      // Get text content, excluding footer (timestamp, copy button)
      const clone = messageEl.cloneNode(true);
      const footer = clone.querySelector('.message-footer');
      if (footer) footer.remove();
      const attachments = clone.querySelector('.message-attachments');
      if (attachments) attachments.remove();

      const text = clone.textContent.trim();

      navigator.clipboard.writeText(text).then(() => {
        // Show copied state
        copyBtn.classList.add('copied');
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>`;

        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>`;
        }, 1500);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Search functionality
    let searchMatches = [];
    let currentSearchIndex = -1;
    let searchDebounceTimer = null;

    // Workflow state
    let activeWorkflow = null;

    async function toggleWorkflows() {
      const area = document.getElementById('workflows-area');
      if (area.classList.contains('active')) {
        closeWorkflows();
      } else {
        // Hide mode toggle, search and chat areas when workflows is open
        document.getElementById('mode-toggle-area').style.display = 'none';
        document.getElementById('search-area').style.display = 'none';
        document.getElementById('chat-area').style.display = 'none';
        area.classList.add('active');
        try {
          const commands = await window.pocketAgent.getCommands();
          const grid = document.getElementById('workflows-grid');
          grid.innerHTML = '';
          commands.forEach(cmd => {
            const btn = document.createElement('button');
            btn.className = 'workflow-btn';
            btn.title = cmd.description || cmd.name;
            btn.textContent = cmd.name;
            btn.onclick = () => { playNormalClick(); selectWorkflow(cmd); };
            grid.appendChild(btn);
          });
        } catch (err) {
          console.error('Failed to load commands:', err);
        }
      }
    }

    function closeWorkflows() {
      document.getElementById('workflows-area').classList.remove('active');
      document.getElementById('mode-toggle-area').style.display = '';
      document.getElementById('search-area').style.display = '';
      document.getElementById('chat-area').style.display = '';
    }

    // Global Chat
    const CHAT_FUN_WORDS = [
      'moonbeam', 'thundercat', 'starfox', 'cosmicpug', 'neonpickle',
      'turbosloth', 'wizardbeard', 'rocketpants', 'chaosmuffin', 'sparkplug',
      'pixeldust', 'lasercat', 'quantumtoast', 'cyberfox', 'stardust',
      'moonpickle', 'thundermuffin', 'neonsloth', 'cosmicbeard', 'turbocat',
      'wizardpants', 'rocketfox', 'chaosdust', 'sparkbeam', 'pixeltoast',
      'lazerpug', 'quantumpickle', 'cybermuffin', 'starsloth', 'mooncat',
      'thunderdust', 'neonbeard', 'cosmicpants', 'turbofox', 'wizardpug',
      'rocketsloth', 'chaosbeam', 'sparkcat', 'pixelpickle', 'lazertoast',
    ];

    const CHAT_SENDER_COLORS = [
      '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
      '#1abc9c', '#e67e22', '#e91e63', '#00bcd4', '#8bc34a',
    ];

    function hashUsername(username) {
      let hash = 0;
      for (let i = 0; i < username.length; i++) {
        hash = ((hash << 5) - hash) + username.charCodeAt(i);
        hash |= 0;
      }
      return Math.abs(hash);
    }

    function getSenderColor(username) {
      return CHAT_SENDER_COLORS[hashUsername(username) % CHAT_SENDER_COLORS.length];
    }

    async function tryRegisterUsername(name) {
      try {
        const res = await fetch(`${CHAT_API_URL}/api/register-username`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: name }),
        });
        const data = await res.json();
        return data.ok === true;
      } catch { return false; }
    }

    async function getOrCreateChatUsername() {
      // Load admin key
      try {
        chatAdminKey = (await window.pocketAgent.getSetting('chat.adminKey')) || '';
        console.log('[Chat] Admin key loaded, length:', chatAdminKey.length);
      } catch (e) { console.log('[Chat] Admin key load failed:', e); chatAdminKey = ''; }

      try {
        const existing = await window.pocketAgent.getSetting('chat.username');
        console.log('[Chat] Username loaded:', existing);
        if (existing) {
          globalChatUsername = existing;
          return existing;
        }
      } catch { /* no saved username */ }

      // Generate from profile name or fallback
      let firstName = 'anon';
      try {
        const name = await window.pocketAgent.getSetting('profile.name');
        if (name) firstName = name.split(' ')[0].toLowerCase().replace(/[^a-z]/g, '');
      } catch { /* use default */ }

      // Truncate firstName so total stays â‰¤ 15 (name + dash + word)
      if (firstName.length > 5) firstName = firstName.slice(0, 5);

      // Try up to 5 times with different fun words
      const shuffled = [...CHAT_FUN_WORDS].sort(() => Math.random() - 0.5);
      let username = '';
      for (let i = 0; i < Math.min(5, shuffled.length); i++) {
        const candidate = `${firstName}-${shuffled[i]}`.slice(0, 15);
        const registered = await tryRegisterUsername(candidate);
        if (registered) {
          username = candidate;
          break;
        }
      }

      // Fallback: add random digits
      if (!username) {
        const fallback = `${firstName}-${Math.floor(Math.random() * 10000)}`.slice(0, 15);
        await tryRegisterUsername(fallback);
        username = fallback;
      }

      try {
        await window.pocketAgent.setSetting('chat.username', username);
      } catch { /* best effort */ }

      globalChatUsername = username;
      return username;
    }

    function renderGlobalChatMessages() {
      const container = document.getElementById('global-chat-messages');
      container.innerHTML = '';

      if (globalChatMessages.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'global-chat-empty';
        empty.textContent = "no one's here yet... say something!";
        container.appendChild(empty);
        return;
      }

      globalChatMessages.forEach(msg => {
        const el = createGlobalChatBubble(msg);
        container.appendChild(el);
      });

      container.scrollTop = container.scrollHeight;
    }

    function createGlobalChatBubble(msg) {
      const isSelf = msg.username === globalChatUsername;
      const tier = msg.tier || 0;
      const tierInfo = TIER_CONFIG[tier] || TIER_CONFIG[0];
      const color = msg.admin ? '#f59e0b' : (isSelf ? '' : getSenderColor(msg.username));

      // Wrapper holds sender label above + bubble below
      const wrapper = document.createElement('div');
      wrapper.className = `global-chat-wrapper ${isSelf ? 'self' : 'other'}`;

      // Sender label (outside bubble)
      const sender = document.createElement('div');
      sender.className = 'global-chat-sender';
      if (msg.admin) {
        const tick = document.createElement('span');
        tick.className = 'verified-badge';
        tick.innerHTML = '<svg viewBox="0 0 40 40"><path d="M19.998 3.094L14.638 0l-2.972 5.15H5.432v6.354L0 14.64 3.094 20 0 25.359l5.432 3.137v6.354h6.234L14.638 40l5.36-3.094L25.358 40l2.972-5.15h6.238v-6.354L40 25.359 36.905 20 40 14.641l-5.432-3.137V5.15h-6.238L25.358 0l-5.36 3.094z" fill="#3b82f6"/><path d="M17.204 27.377l-6.952-6.952 2.828-2.828 4.124 4.124 8.492-8.492 2.828 2.828-11.32 11.32z" fill="#fff"/></svg>';
        sender.appendChild(tick);
      } else if (tier > 0 && tierInfo.badge) {
        const badge = document.createElement('span');
        badge.className = 'tier-badge tier-badge-' + tierInfo.cssClass.replace('tier-', '');
        badge.textContent = tierInfo.badge;
        sender.appendChild(badge);
      }
      const name = document.createElement('span');
      name.textContent = msg.username;
      if (msg.admin) {
        name.className = 'admin-username';
        name.setAttribute('data-text', msg.username);
      } else if (tier > 0 && tierInfo.cssClass) {
        name.className = tierInfo.cssClass;
        // Tiers with ::before pseudo-elements need data-text
        if (tier >= 9) name.setAttribute('data-text', msg.username);
      } else if (!isSelf) {
        name.style.color = color;
      }
      // Tag non-self, non-admin names for tier_update lookups
      if (!isSelf && !msg.admin) {
        name.dataset.chatUsername = msg.username;
      }
      sender.appendChild(name);

      // Admin hover popover on other users' names (not self, not admin)
      if (chatIsAdmin && !isSelf && !msg.admin) {
        name.style.cursor = 'pointer';
        name.addEventListener('mouseenter', (e) => {
          const uname = msg.username;
          const uMinTier = userMinTierMap.get(uname) || 0;
          showAdminTierPopover(uname, tier, uMinTier, e.target);
        });
        name.addEventListener('mouseleave', () => {
          scheduleHideAdminTierPopover();
        });
      }

      wrapper.appendChild(sender);

      // Bubble
      const div = document.createElement('div');
      div.className = `message ${isSelf ? 'global-chat-self' : 'global-chat-other'}`;
      if (msg.admin) div.classList.add('global-chat-admin');
      const text = document.createElement('span');
      text.textContent = msg.text;
      div.appendChild(text);
      wrapper.appendChild(div);

      return wrapper;
    }

    function addGlobalChatMessage(msg) {
      globalChatMessages.push(msg);
      const container = document.getElementById('global-chat-messages');
      // Remove empty state if present
      const empty = container.querySelector('.global-chat-empty');
      if (empty) empty.remove();

      const el = createGlobalChatBubble(msg);
      container.appendChild(el);
      container.scrollTop = container.scrollHeight;
    }

    let chatActivityInterval = null;

    function connectChatWs() {
      if (chatWs && (chatWs.readyState === WebSocket.OPEN || chatWs.readyState === WebSocket.CONNECTING)) return;

      chatWs = new WebSocket(CHAT_WS_URL);

      chatWs.onopen = () => {
        const dot = document.getElementById('chat-status-dot');
        if (dot) dot.classList.add('connected');
        const joinPayload = { type: 'join', username: globalChatUsername };
        if (chatAdminKey) joinPayload.adminKey = chatAdminKey;
        console.log('[Chat WS] Joining as:', globalChatUsername, 'adminKey present:', !!chatAdminKey, 'keyLen:', chatAdminKey.length);
        chatWs.send(JSON.stringify(joinPayload));
        // Always subscribe to messages so unread notifications work
        chatWs.send(JSON.stringify({ type: 'enter_chat' }));
      };

      chatWs.onmessage = (event) => {
        let data;
        try { data = JSON.parse(event.data); } catch { return; }

        if (data.type === 'joined') {
          chatIsAdmin = !!data.admin;
          globalChatSelfTier = data.tier || 0;
          updateHeaderTierBadge();
          // Show admin gear if admin
          const adminWrap = document.getElementById('admin-menu-wrap');
          if (adminWrap) adminWrap.style.display = chatIsAdmin ? '' : 'none';
        } else if (data.type === 'tier_change') {
          const oldTier = globalChatSelfTier;
          globalChatSelfTier = data.tier || 0;
          // Update own messages so re-renders preserve the tier
          globalChatMessages.forEach(m => {
            if (m.username === globalChatUsername) m.tier = data.tier;
          });
          updateHeaderTierBadge();
          if (data.tier > oldTier) {
            const info = TIER_CONFIG[data.tier] || TIER_CONFIG[0];
            showTierToast(info.badge + ' You reached ' + info.name + '!');
          }
        } else if (data.type === 'history') {
          globalChatMessages = (data.messages || []).map(m => {
            if (m.minTier !== undefined) userMinTierMap.set(m.username, m.minTier);
            return {
              username: m.username,
              text: m.text,
              ts: Number(m.ts),
              admin: !!m.admin,
              tier: m.tier || 0,
            };
          });
          if (globalChatMode) renderGlobalChatMessages();
        } else if (data.type === 'message') {
          if (data.minTier !== undefined) userMinTierMap.set(data.username, data.minTier);
          addGlobalChatMessage({ username: data.username, text: data.text, ts: data.ts, admin: !!data.admin, tier: data.tier || 0 });
          if (!globalChatMode) {
            chatUnreadCount++;
            updateUnreadBadge();
          }
        } else if (data.type === 'message_ack') {
          // Server confirmed our message was saved â€” add it to chat
          if (data.minTier !== undefined) userMinTierMap.set(data.username, data.minTier);
          addGlobalChatMessage({ username: data.username, text: data.text, ts: data.ts, admin: !!data.admin, tier: data.tier || 0 });
        } else if (data.type === 'chat_cleared') {
          globalChatMessages = [];
          const container = document.getElementById('global-chat-messages');
          container.innerHTML = '';
          // Show system message
          const sysMsg = document.createElement('div');
          sysMsg.className = 'global-chat-empty';
          sysMsg.textContent = 'Chat was cleared by admin';
          container.appendChild(sysMsg);
        } else if (data.type === 'tier_update') {
          userMinTierMap.set(data.username, data.minTier);
          // Update tier in message data so re-renders preserve the change
          globalChatMessages.forEach(m => {
            if (m.username === data.username) m.tier = data.tier;
          });
          // Update existing bubbles for this user
          document.querySelectorAll('[data-chat-username="' + data.username + '"]').forEach(nameEl => {
            const tierInfo = TIER_CONFIG[data.tier] || TIER_CONFIG[0];
            nameEl.className = '';
            if (data.tier > 0 && tierInfo.cssClass) {
              nameEl.className = tierInfo.cssClass;
              if (data.tier >= 9) nameEl.setAttribute('data-text', data.username);
              else nameEl.removeAttribute('data-text');
            }
            // Update badge in same sender div
            const senderDiv = nameEl.parentElement;
            if (senderDiv) {
              const oldBadge = senderDiv.querySelector('.tier-badge');
              if (oldBadge) oldBadge.remove();
              if (data.tier > 0 && tierInfo.badge) {
                const badge = document.createElement('span');
                badge.className = 'tier-badge tier-badge-' + tierInfo.cssClass.replace('tier-', '');
                badge.textContent = tierInfo.badge;
                senderDiv.insertBefore(badge, nameEl);
              }
            }
          });
          // If it's current user, update self tier
          if (data.username === globalChatUsername) {
            globalChatSelfTier = data.tier;
            updateHeaderTierBadge();
          }
          // Update popover if it's showing for this user
          if (adminTierPopoverEl && adminTierPopoverEl.dataset.username === data.username) {
            updateAdminTierPopoverContent(data.username, data.tier, data.minTier);
          }
        } else if (data.type === 'counts') {
          updateChatCounts(data.online, data.inChat);
        } else if (data.type === 'error') {
          showChatToast(data.message);
        }
      };

      chatWs.onclose = (event) => {
        console.log('[Chat WS] Closed, code:', event.code, 'reason:', event.reason);
        const dot = document.getElementById('chat-status-dot');
        if (dot) dot.classList.remove('connected');
        clearTimeout(chatWsReconnectTimer);
        // Don't retry if username is reserved and admin key is wrong
        if (event.code === 4003) {
          console.warn('[Chat WS] Username reserved â€” admin key mismatch, not reconnecting');
          showChatToast('username reserved â€” check admin key in settings');
          return;
        }
        chatWsReconnectTimer = setTimeout(connectChatWs, 3000);
      };

      chatWs.onerror = () => {};
    }

    function sendChatWs(data) {
      if (chatWs && chatWs.readyState === WebSocket.OPEN) {
        chatWs.send(JSON.stringify(data));
      }
    }

    function enterChatActive() {
      sendChatWs({ type: 'enter_chat' });
      // Ping activity every 5 min to stay "in chat"
      clearInterval(chatActivityInterval);
      chatActivityInterval = setInterval(() => {
        sendChatWs({ type: 'chat_active' });
      }, 5 * 60 * 1000);
    }

    function leaveChatActive() {
      clearInterval(chatActivityInterval);
      chatActivityInterval = null;
      // Don't send leave_chat â€” stay subscribed so unread notifications work
    }

    const chatSendTimestamps = [];
    const CHAT_RATE_LIMIT_WINDOW = 10_000;
    const CHAT_RATE_LIMIT_MAX = 5;
    let lastChatMessageText = '';

    const CHAT_ALLOWED_LINKS = [
      /https?:\/\/(www\.)?(youtube\.com|youtu\.be|m\.youtube\.com)(\/\S*)?/i,
      /https?:\/\/(www\.)?instagram\.com(\/\S*)?/i,
      /https?:\/\/(www\.)?(tiktok\.com|vm\.tiktok\.com)(\/\S*)?/i,
      /https?:\/\/(www\.)?(x\.com|twitter\.com)(\/\S*)?/i,
      /https?:\/\/(www\.)?skool\.com\/kenkai(\/\S*|$)?(?![a-z0-9-])/i,
    ];
    const CHAT_URL_REGEX = /https?:\/\/\S+|www\.\S+/gi;

    function chatHasBlockedLinks(text) {
      const urls = text.match(CHAT_URL_REGEX);
      if (!urls) return false;
      for (const url of urls) {
        let allowed = false;
        for (const pattern of CHAT_ALLOWED_LINKS) {
          pattern.lastIndex = 0;
          if (pattern.test(url)) { allowed = true; break; }
        }
        if (!allowed) return true;
      }
      return false;
    }

    function sendGlobalChatMessage() {
      const text = input.value.trim();
      if (!text) return;

      const now = Date.now();

      // Client-side rate limit
      while (chatSendTimestamps.length && now - chatSendTimestamps[0] >= CHAT_RATE_LIMIT_WINDOW) {
        chatSendTimestamps.shift();
      }
      if (chatSendTimestamps.length >= CHAT_RATE_LIMIT_MAX) {
        showChatToast('easy tiger, slow down');
        return;
      }

      // Client-side duplicate check
      if (text === lastChatMessageText) {
        showChatToast('you just said that');
        return;
      }

      // Client-side link check
      if (chatHasBlockedLinks(text)) {
        showChatToast("that link isn't allowed here");
        return;
      }

      chatSendTimestamps.push(now);
      lastChatMessageText = text;

      // Don't optimistically add â€” wait for server echo so all users see the same state
      input.value = '';
      autoResizeTextarea();
      sendChatWs({ type: 'message', text });
    }

    let chatToastTimer = null;
    function showChatToast(msg) {
      const existing = document.getElementById('chat-toast');
      // Clear any previous state
      clearTimeout(chatToastTimer);
      existing.classList.remove('show', 'exiting');

      existing.innerHTML = `
        <div class="toast-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/>
          </svg>
        </div>
        <div class="toast-message">${msg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
      `;

      // Force reflow so animation restarts
      void existing.offsetWidth;
      existing.classList.add('show');

      chatToastTimer = setTimeout(() => {
        existing.classList.add('exiting');
        setTimeout(() => {
          existing.classList.remove('show', 'exiting');
        }, 300);
      }, 2500);
    }

    function showTierToast(msg) {
      const existing = document.getElementById('chat-toast');
      clearTimeout(chatToastTimer);
      existing.classList.remove('show', 'exiting', 'tier-toast');
      existing.innerHTML = `
        <div class="toast-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
          </svg>
        </div>
        <div class="toast-message">${msg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
      `;
      void existing.offsetWidth;
      existing.classList.add('show', 'tier-toast');
      chatToastTimer = setTimeout(() => {
        existing.classList.add('exiting');
        setTimeout(() => {
          existing.classList.remove('show', 'exiting', 'tier-toast');
        }, 300);
      }, 3500);
    }

    function updateHeaderTierBadge() {
      const badge = document.getElementById('chat-username-badge');
      if (!badge) return;
      const tier = globalChatSelfTier;
      const info = TIER_CONFIG[tier] || TIER_CONFIG[0];
      badge.className = 'chat-username-badge';
      if (chatIsAdmin) {
        badge.innerHTML = '';
        const tick = document.createElement('span');
        tick.className = 'verified-badge';
        tick.innerHTML = '<svg viewBox="0 0 40 40" style="width:14px;height:14px"><path d="M19.998 3.094L14.638 0l-2.972 5.15H5.432v6.354L0 14.64 3.094 20 0 25.359l5.432 3.137v6.354h6.234L14.638 40l5.36-3.094L25.358 40l2.972-5.15h6.238v-6.354L40 25.359 36.905 20 40 14.641l-5.432-3.137V5.15h-6.238L25.358 0l-5.36 3.094z" fill="#3b82f6"/><path d="M17.204 27.377l-6.952-6.952 2.828-2.828 4.124 4.124 8.492-8.492 2.828 2.828-11.32 11.32z" fill="#fff"/></svg>';
        badge.appendChild(tick);
        const nameSpan = document.createElement('span');
        nameSpan.className = 'admin-username';
        nameSpan.textContent = globalChatUsername;
        nameSpan.setAttribute('data-text', globalChatUsername);
        badge.appendChild(nameSpan);
      } else if (tier > 0) {
        badge.innerHTML = '';
        const badgeEmoji = document.createElement('span');
        badgeEmoji.className = 'tier-badge tier-badge-' + info.cssClass.replace('tier-', '');
        badgeEmoji.textContent = info.badge + ' ';
        badge.appendChild(badgeEmoji);
        const nameSpan = document.createElement('span');
        nameSpan.className = info.cssClass;
        nameSpan.textContent = globalChatUsername;
        if (tier >= 9) nameSpan.setAttribute('data-text', globalChatUsername);
        badge.appendChild(nameSpan);
        const tierLabel = document.createTextNode(' \u00B7 ' + info.name);
        badge.appendChild(tierLabel);
      } else {
        badge.textContent = globalChatUsername;
      }
    }

    function buildTierTooltipHTML() {
      const tier = globalChatSelfTier;
      const currentInfo = TIER_CONFIG[tier] || TIER_CONFIG[0];
      const nextTier = tier < 10 ? tier + 1 : null;
      const nextInfo = nextTier ? TIER_CONFIG[nextTier] : null;
      const uname = globalChatUsername;

      let html = '<div class="tier-tooltip-content">';
      html += '<div class="tier-tooltip-current">';
      if (tier > 0) {
        html += '<span class="tier-tooltip-badge">' + currentInfo.badge + '</span> ';
        html += '<strong>' + currentInfo.name + '</strong> (Tier ' + tier + ')';
      } else {
        html += '<strong>No Tier</strong>';
      }
      html += '</div>';

      if (nextInfo) {
        html += '<div class="tier-tooltip-next">';
        html += '<span style="color:var(--text-secondary)">Next: </span>';
        html += '<span class="tier-tooltip-badge">' + nextInfo.badge + '</span> ';
        html += '<strong>' + nextInfo.name + '</strong>';
        html += ' &mdash; ' + nextInfo.threshold + ' msgs/week';
        html += '</div>';
      } else {
        html += '<div class="tier-tooltip-next" style="color:var(--accent)">Max tier reached!</div>';
      }

      html += '<div class="tier-tooltip-divider"></div>';
      html += '<div class="tier-tooltip-list">';
      for (let i = 1; i <= 10; i++) {
        const t = TIER_CONFIG[i];
        const active = i <= tier;
        const isCurrent = i === tier;
        html += '<div class="tier-tooltip-row' + (active ? ' active' : '') + (isCurrent ? ' current' : '') + '">';
        html += '<span class="tier-tooltip-badge tier-badge-' + t.cssClass.replace('tier-', '') + '">' + t.badge + '</span>';
        html += '<span class="tier-tooltip-name-preview"><span class="' + t.cssClass + '"' + (i >= 9 ? ' data-text="' + uname + '"' : '') + '>' + uname + '</span></span>';
        html += '<span class="tier-tooltip-tier-label">' + t.name + '</span>';
        html += '<span class="tier-tooltip-threshold">' + t.threshold + '/wk</span>';
        if (isCurrent) html += '<span class="tier-tooltip-you">YOU</span>';
        html += '</div>';
      }
      html += '</div>';
      html += '</div>';
      return html;
    }

    let tierTooltipEl = null;
    function toggleTierTooltip(e) {
      if (tierTooltipEl) {
        tierTooltipEl.remove();
        tierTooltipEl = null;
        return;
      }
      tierTooltipEl = document.createElement('div');
      tierTooltipEl.className = 'tier-tooltip';
      tierTooltipEl.innerHTML = buildTierTooltipHTML();
      document.body.appendChild(tierTooltipEl);

      // Position below the badge
      const badge = document.getElementById('chat-username-badge');
      if (badge) {
        const rect = badge.getBoundingClientRect();
        tierTooltipEl.style.top = (rect.bottom + 6) + 'px';
        tierTooltipEl.style.right = (window.innerWidth - rect.right) + 'px';
      }

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', closeTierTooltip, { once: true });
      }, 0);
    }
    function closeTierTooltip(e) {
      if (tierTooltipEl) {
        if (tierTooltipEl.contains(e?.target)) {
          document.addEventListener('click', closeTierTooltip, { once: true });
          return;
        }
        tierTooltipEl.remove();
        tierTooltipEl = null;
      }
    }

    // --- Admin gear dropdown ---
    (function initAdminGear() {
      const gearBtn = document.getElementById('admin-gear-btn');
      const dropdown = document.getElementById('admin-dropdown');
      const clearBtn = document.getElementById('admin-clear-chat');
      if (gearBtn && dropdown) {
        gearBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          playNormalClick();
          dropdown.classList.toggle('open');
        });
        document.addEventListener('click', () => dropdown.classList.remove('open'));
      }
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          playNormalClick();
          sendChatWs({ type: 'clear_chat' });
          dropdown.classList.remove('open');
        });
      }
    })();

    // --- Admin tier popover ---
    let adminTierPopoverEl = null;
    let adminTierPopoverHideTimer = null;

    function showAdminTierPopover(username, currentTier, minTier, anchorEl) {
      clearTimeout(adminTierPopoverHideTimer);
      hideAdminTierPopover();

      const popover = document.createElement('div');
      popover.className = 'admin-tier-popover';
      popover.dataset.username = username;
      updateAdminTierPopoverContentEl(popover, username, currentTier, minTier);

      popover.addEventListener('mouseenter', () => clearTimeout(adminTierPopoverHideTimer));
      popover.addEventListener('mouseleave', () => scheduleHideAdminTierPopover());

      document.body.appendChild(popover);
      adminTierPopoverEl = popover;

      // Position near anchor
      const rect = anchorEl.getBoundingClientRect();
      popover.style.left = rect.left + 'px';
      popover.style.top = (rect.bottom + 6) + 'px';
      // Keep within viewport
      const pRect = popover.getBoundingClientRect();
      if (pRect.right > window.innerWidth - 10) {
        popover.style.left = (window.innerWidth - pRect.width - 10) + 'px';
      }
    }

    function updateAdminTierPopoverContent(username, tier, minTier) {
      if (adminTierPopoverEl) updateAdminTierPopoverContentEl(adminTierPopoverEl, username, tier, minTier);
    }

    function updateAdminTierPopoverContentEl(el, username, currentTier, minTier) {
      const tierInfo = TIER_CONFIG[currentTier] || TIER_CONFIG[0];
      const floorInfo = TIER_CONFIG[minTier] || TIER_CONFIG[0];
      const floorLabel = minTier > 0 ? ('Tier ' + minTier + ' - ' + floorInfo.name) : 'None';

      el.innerHTML = '';
      const header = document.createElement('div');
      header.className = 'atp-header';
      header.textContent = username;
      el.appendChild(header);

      const current = document.createElement('div');
      current.className = 'atp-current';
      current.textContent = currentTier > 0
        ? 'Current: ' + tierInfo.badge + ' Tier ' + currentTier + ' - ' + tierInfo.name
        : 'Current: No Tier';
      el.appendChild(current);

      const floor = document.createElement('div');
      floor.className = 'atp-floor';

      const floorSpan = document.createElement('span');
      floorSpan.className = 'atp-floor-label';
      floorSpan.textContent = 'Floor: ' + floorLabel;
      floor.appendChild(floorSpan);

      const downBtn = document.createElement('button');
      downBtn.className = 'atp-btn';
      downBtn.textContent = '\u2212';
      downBtn.disabled = minTier <= 0;
      downBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        playNormalClick();
        adminSetFloor(username, minTier - 1);
      });
      floor.appendChild(downBtn);

      const upBtn = document.createElement('button');
      upBtn.className = 'atp-btn';
      upBtn.textContent = '+';
      upBtn.disabled = minTier >= 10;
      upBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        playNormalClick();
        adminSetFloor(username, minTier + 1);
      });
      floor.appendChild(upBtn);

      el.appendChild(floor);
    }

    function scheduleHideAdminTierPopover() {
      clearTimeout(adminTierPopoverHideTimer);
      adminTierPopoverHideTimer = setTimeout(hideAdminTierPopover, 300);
    }

    function hideAdminTierPopover() {
      clearTimeout(adminTierPopoverHideTimer);
      if (adminTierPopoverEl) {
        adminTierPopoverEl.remove();
        adminTierPopoverEl = null;
      }
    }

    function adminSetFloor(username, newMinTier) {
      const clamped = Math.max(0, Math.min(10, newMinTier));
      sendChatWs({ type: 'set_min_tier', targetUsername: username, minTier: clamped });
    }

    function updateChatCounts(online, inChat) {
      const el = document.getElementById('chat-online-stats');
      if (el) el.textContent = `${online} online Â· ${inChat} in chat`;
    }

    function updateUnreadBadge() {
      const btn = document.getElementById('chat-toggle-btn');
      if (!btn) return;
      let badge = btn.querySelector('.chat-unread-badge');
      if (chatUnreadCount > 0 && !globalChatMode) {
        if (!badge) {
          badge = document.createElement('span');
          badge.className = 'chat-unread-badge';
          btn.appendChild(badge);
        }
        badge.textContent = chatUnreadCount > 99 ? '99+' : String(chatUnreadCount);
      } else if (badge) {
        badge.remove();
      }
    }

    async function toggleGlobalChat() {
      globalChatMode = !globalChatMode;
      const chatToggle = document.getElementById('chat-toggle-btn');
      const tabsCont = document.getElementById('tabs-container');
      const chatHeader = document.getElementById('global-chat-header');
      const messagesEl = document.getElementById('messages');
      const globalMsgsEl = document.getElementById('global-chat-messages');
      const modelBadge = document.getElementById('model-badge');
      const versionBadge = document.getElementById('version-badge');
      const updateBadge = document.getElementById('update-badge');
      const statsEl = document.getElementById('stats');
      const chatOnlineStats = document.getElementById('chat-online-stats');
      const chatUsernameBadge = document.getElementById('chat-username-badge');
      const searchArea = document.getElementById('search-area');
      const workflowsArea = document.getElementById('workflows-area');
      const bgTasksArea = document.getElementById('background-tasks-area');
      const attachBtn = document.querySelector('.attach-btn');
      const workflowBadge = document.getElementById('workflow-badge-container');
      const scrollTopBtn = document.getElementById('scroll-top-btn');
      const scrollBottomBtn = document.getElementById('scroll-bottom-btn');

      if (globalChatMode) {
        // Enter chat mode â€” clear unread
        chatUnreadCount = 0;
        updateUnreadBadge();
        const username = await getOrCreateChatUsername();
        updateHeaderTierBadge();
        document.getElementById('chat-username-badge').onclick = toggleTierTooltip;

        tabsCont.style.display = 'none';
        chatHeader.style.display = 'flex';
        messagesEl.style.display = 'none';
        globalMsgsEl.style.display = 'flex';
        modelBadge.style.display = 'none';
        versionBadge.style.display = 'none';
        updateBadge.style.display = 'none';
        statsEl.style.display = 'none';
        chatUsernameBadge.style.display = '';
        chatOnlineStats.style.display = '';
        document.getElementById('mode-toggle-area').style.display = 'none';
        searchArea.style.display = 'none';
        workflowsArea.style.display = 'none';
        bgTasksArea.style.display = 'none';
        if (attachBtn) attachBtn.style.display = 'none';
        if (workflowBadge) workflowBadge.style.display = 'none';
        if (scrollTopBtn) scrollTopBtn.style.display = 'none';
        if (scrollBottomBtn) scrollBottomBtn.style.display = 'none';
        document.getElementById('gchat-scroll-top-btn').style.display = '';
        document.getElementById('gchat-scroll-bottom-btn').style.display = '';
        chatToggle.classList.add('active');
        input.placeholder = 'say something...';

        // Show admin gear if admin
        const adminWrap = document.getElementById('admin-menu-wrap');
        if (adminWrap) adminWrap.style.display = chatIsAdmin ? '' : 'none';

        renderGlobalChatMessages();
        enterChatActive();
      } else {
        // Exit chat mode
        leaveChatActive();
        hideAdminTierPopover();
        tabsCont.style.display = '';
        chatHeader.style.display = 'none';
        messagesEl.style.display = '';
        globalMsgsEl.style.display = 'none';
        modelBadge.style.display = '';
        versionBadge.style.display = '';
        updateBadge.style.display = '';
        statsEl.style.display = '';
        chatUsernameBadge.style.display = 'none';
        chatOnlineStats.style.display = 'none';
        document.getElementById('mode-toggle-area').style.display = '';
        searchArea.style.display = '';
        workflowsArea.style.display = '';
        // Only show bg tasks area if there are active tasks
        if (getBackgroundTaskCount(currentSessionId) > 0) {
          bgTasksArea.style.display = '';
        }
        if (attachBtn) attachBtn.style.display = '';
        if (workflowBadge) workflowBadge.style.display = '';
        if (scrollTopBtn) scrollTopBtn.style.display = '';
        if (scrollBottomBtn) scrollBottomBtn.style.display = '';
        document.getElementById('gchat-scroll-top-btn').style.display = 'none';
        document.getElementById('gchat-scroll-bottom-btn').style.display = 'none';
        gchatScrollTopBtn.classList.remove('visible');
        gchatScrollBottomBtn.classList.remove('visible');
        chatToggle.classList.remove('active');
        input.placeholder = "what's on your mind? \u{1F431}";
      }
    }

    // Background tasks tracking
    let backgroundTasksBySession = new Map(); // sessionId -> Map(taskId -> { type, description })

    function addBackgroundTask(sessionId, taskId, type, description) {
      if (!backgroundTasksBySession.has(sessionId)) {
        backgroundTasksBySession.set(sessionId, new Map());
      }
      backgroundTasksBySession.get(sessionId).set(taskId, { type, description });
      updateBackgroundTasksUI();
    }

    function getBackgroundTaskCount(sessionId) {
      const tasks = backgroundTasksBySession.get(sessionId || currentSessionId);
      return tasks ? tasks.size : 0;
    }

    function updateBackgroundTasksUI() {
      const area = document.getElementById('background-tasks-area');
      const countEl = area.querySelector('.bg-task-count');
      const listEl = document.getElementById('background-tasks-list');
      const tasks = backgroundTasksBySession.get(currentSessionId);
      const count = tasks ? tasks.size : 0;

      if (count === 0) {
        area.style.display = 'none';
        area.classList.remove('active');
        return;
      }

      area.style.display = '';
      countEl.textContent = count;

      // Update vertical list â€” only current session's tasks
      listEl.innerHTML = '';
      for (const [tid, task] of tasks) {
        const item = document.createElement('div');
        item.className = 'bg-task-item';
        item.innerHTML = `
          <span class="bg-task-dot"></span>
          <span class="bg-task-type">${escapeHtml(task.type)}</span>
          <span class="bg-task-label" title="${escapeHtml(task.description)}">${escapeHtml(task.description)}</span>
          <button class="bg-task-close" onclick="playNormalClick(); removeBackgroundTask('${currentSessionId}', '${tid}')" title="Stop task">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>`;
        listEl.appendChild(item);
      }
    }

    function removeBackgroundTask(sessionId, taskId) {
      const tasks = backgroundTasksBySession.get(sessionId);
      if (tasks) {
        tasks.delete(taskId);
        if (tasks.size === 0) backgroundTasksBySession.delete(sessionId);
      }
      updateBackgroundTasksUI();
    }

    function toggleBackgroundTasks() {
      const area = document.getElementById('background-tasks-area');
      if (area.classList.contains('active')) {
        closeBackgroundTasks();
      } else {
        area.classList.add('active');
      }
    }

    function closeBackgroundTasks() {
      document.getElementById('background-tasks-area').classList.remove('active');
    }

    function selectWorkflow(command) {
      activeWorkflow = command;
      closeWorkflows();
      const container = document.getElementById('workflow-badge-container');
      container.innerHTML = `<span class="workflow-badge">${command.name}<button class="workflow-badge-remove" onclick="playNormalClick(); clearWorkflow()" title="Remove workflow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button></span>`;
      input.placeholder = `add context for /${command.name}...`;
      input.focus();
    }

    function clearWorkflow() {
      activeWorkflow = null;
      document.getElementById('workflow-badge-container').innerHTML = '';
      input.placeholder = "what's on your mind? \u{1F431}";
    }

    // ============ Agent Mode Toggle ============

    let currentAgentMode = 'coder';

    async function initAgentMode() {
      try {
        const mode = await window.pocketAgent.getMode();
        currentAgentMode = mode || 'coder';
        updateModeUI(currentAgentMode);
      } catch (err) {
        console.error('Failed to load agent mode:', err);
      }

      // Listen for mode changes from other sources
      window.pocketAgent.onModeChanged((mode) => {
        currentAgentMode = mode;
        updateModeUI(mode);
      });
    }

    function setAgentMode(mode) {
      if (mode === currentAgentMode) return;
      currentAgentMode = mode;
      updateModeUI(mode);
      window.pocketAgent.setMode(mode).catch(err => {
        console.error('Failed to set agent mode:', err);
      });
    }

    function updateModeUI(mode) {
      const generalBtn = document.getElementById('mode-btn-general');
      const coderBtn = document.getElementById('mode-btn-coder');
      if (!generalBtn || !coderBtn) return;

      generalBtn.classList.toggle('active', mode === 'general');
      coderBtn.classList.toggle('active', mode === 'coder');
    }

    function toggleSearch() {
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');

      if (searchArea.classList.contains('searching')) {
        closeSearch();
      } else {
        // Hide mode toggle, workflows and chat when search is open
        document.getElementById('mode-toggle-area').style.display = 'none';
        document.getElementById('workflows-area').style.display = 'none';
        document.getElementById('chat-area').style.display = 'none';
        searchArea.classList.add('searching');
        searchInput.focus();
      }
    }

    function closeSearch() {
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');

      searchArea.classList.remove('searching');
      searchInput.value = '';
      clearSearchHighlights();
      updateSearchResultsCount(0, 0);
      searchMatches = [];
      currentSearchIndex = -1;
      // Restore mode toggle, workflows and chat visibility
      document.getElementById('mode-toggle-area').style.display = '';
      document.getElementById('workflows-area').style.display = '';
      document.getElementById('chat-area').style.display = '';
    }

    function handleSearchInput(event) {
      // Debounce search
      clearTimeout(searchDebounceTimer);
      searchDebounceTimer = setTimeout(() => {
        performSearch(event.target.value);
      }, 150);
    }

    function handleSearchKeydown(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (event.shiftKey) {
          navigateSearch(-1);
        } else {
          navigateSearch(1);
        }
      } else if (event.key === 'Escape') {
        event.preventDefault();
        closeSearch();
      }
    }

    function performSearch(query) {
      clearSearchHighlights();
      searchMatches = [];
      currentSearchIndex = -1;

      if (!query || query.trim().length === 0) {
        updateSearchResultsCount(0, 0);
        updateNavButtons();
        return;
      }

      const searchTerm = query.trim().toLowerCase();
      const messages = messagesDiv.querySelectorAll('.message');

      messages.forEach(msg => {
        // Search in text nodes, excluding timestamps and other meta elements
        const walker = document.createTreeWalker(
          msg,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: function(node) {
              // Skip timestamps and attachment meta
              if (node.parentElement.classList.contains('message-timestamp') ||
                  node.parentElement.classList.contains('message-attachment') ||
                  node.parentElement.classList.contains('attachment-icon')) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );

        let node;
        while (node = walker.nextNode()) {
          const text = node.textContent;
          const lowerText = text.toLowerCase();
          let startIndex = 0;
          let index;

          while ((index = lowerText.indexOf(searchTerm, startIndex)) !== -1) {
            searchMatches.push({
              node: node,
              startOffset: index,
              endOffset: index + searchTerm.length,
              message: msg
            });
            startIndex = index + 1;
          }
        }
      });

      // Apply highlights
      highlightMatches();
      updateSearchResultsCount(searchMatches.length > 0 ? 1 : 0, searchMatches.length);
      updateNavButtons();

      // Navigate to first match
      if (searchMatches.length > 0) {
        currentSearchIndex = 0;
        scrollToCurrentMatch();
      }
    }

    function highlightMatches() {
      // Process matches in reverse order to avoid offset issues
      const matchesByNode = new Map();

      searchMatches.forEach((match, index) => {
        if (!matchesByNode.has(match.node)) {
          matchesByNode.set(match.node, []);
        }
        matchesByNode.get(match.node).push({ ...match, index });
      });

      matchesByNode.forEach((nodeMatches, node) => {
        // Sort in reverse order for safe replacement
        nodeMatches.sort((a, b) => b.startOffset - a.startOffset);

        const text = node.textContent;
        const parent = node.parentNode;
        const fragment = document.createDocumentFragment();

        let currentText = text;
        let parts = [];

        // Build parts array
        for (const match of nodeMatches) {
          const before = currentText.slice(match.endOffset);
          const matchText = currentText.slice(match.startOffset, match.endOffset);
          const remaining = currentText.slice(0, match.startOffset);

          parts.unshift({ type: 'text', content: before });
          parts.unshift({ type: 'match', content: matchText, index: match.index });

          currentText = remaining;
        }
        parts.unshift({ type: 'text', content: currentText });

        // Create nodes from parts
        parts.forEach(part => {
          if (part.type === 'text') {
            if (part.content) {
              fragment.appendChild(document.createTextNode(part.content));
            }
          } else {
            const mark = document.createElement('mark');
            mark.className = 'search-highlight';
            mark.dataset.matchIndex = part.index;
            mark.textContent = part.content;
            fragment.appendChild(mark);
          }
        });

        parent.replaceChild(fragment, node);
      });
    }

    function clearSearchHighlights() {
      const marks = messagesDiv.querySelectorAll('mark.search-highlight');
      marks.forEach(mark => {
        const parent = mark.parentNode;
        const text = document.createTextNode(mark.textContent);
        parent.replaceChild(text, mark);
        // Normalize to merge adjacent text nodes
        parent.normalize();
      });
    }

    function navigateSearch(direction) {
      if (searchMatches.length === 0) return;

      // Remove current highlight
      const currentMark = messagesDiv.querySelector('mark.search-highlight.current');
      if (currentMark) {
        currentMark.classList.remove('current');
      }

      // Update index
      currentSearchIndex += direction;
      if (currentSearchIndex >= searchMatches.length) {
        currentSearchIndex = 0;
      } else if (currentSearchIndex < 0) {
        currentSearchIndex = searchMatches.length - 1;
      }

      // Update count display
      updateSearchResultsCount(currentSearchIndex + 1, searchMatches.length);

      // Scroll to and highlight current match
      scrollToCurrentMatch();
    }

    function scrollToCurrentMatch() {
      const marks = messagesDiv.querySelectorAll('mark.search-highlight');
      marks.forEach((mark, idx) => {
        const matchIndex = parseInt(mark.dataset.matchIndex);
        if (matchIndex === currentSearchIndex) {
          mark.classList.add('current');
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
          mark.classList.remove('current');
        }
      });
    }

    function updateSearchResultsCount(current, total) {
      const countEl = document.getElementById('search-results-count');
      if (total === 0) {
        countEl.textContent = '';
        countEl.classList.remove('has-results');
      } else {
        countEl.textContent = `${current}/${total}`;
        countEl.classList.add('has-results');
      }
    }

    function updateNavButtons() {
      const prevBtn = document.getElementById('search-prev-btn');
      const nextBtn = document.getElementById('search-next-btn');
      const hasMatches = searchMatches.length > 0;

      prevBtn.disabled = !hasMatches;
      nextBtn.disabled = !hasMatches;
    }

    // Keyboard shortcut for search (Cmd/Ctrl + F)
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        e.preventDefault();
        toggleSearch();
      }
    });

    function showEmptyState() {
      messagesDiv.innerHTML = `
        <div class="empty-state">
          <div class="pixel-heart"></div>
          <div class="empty-title">Franky here!</div>
          <div class="empty-subtitle">ready to go whenever you are, i've got your back âœ¨</div>
        </div>
      `;
    }

    function scrollToBottom(instant = false) {
      requestAnimationFrame(() => {
        messagesDiv.scrollTo({
          top: messagesDiv.scrollHeight,
          behavior: instant ? 'instant' : 'smooth'
        });
      });
    }

    function scrollToTop() {
      requestAnimationFrame(() => {
        messagesDiv.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      });
    }

    // Scroll button visibility
    const scrollTopBtn = document.getElementById('scroll-top-btn');
    const scrollBottomBtn = document.getElementById('scroll-bottom-btn');
    const SCROLL_THRESHOLD = 200;

    function updateScrollButtons() {
      const scrollTop = messagesDiv.scrollTop;
      const scrollHeight = messagesDiv.scrollHeight;
      const clientHeight = messagesDiv.clientHeight;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;

      // Show "scroll to top" when scrolled down past threshold
      if (scrollTop > SCROLL_THRESHOLD) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }

      // Show "scroll to bottom" when not at bottom
      if (distanceFromBottom > SCROLL_THRESHOLD) {
        scrollBottomBtn.classList.add('visible');
      } else {
        scrollBottomBtn.classList.remove('visible');
      }
    }

    messagesDiv.addEventListener('scroll', updateScrollButtons);

    // Global chat scroll buttons
    const gchatMsgsDiv = document.getElementById('global-chat-messages');
    const gchatScrollTopBtn = document.getElementById('gchat-scroll-top-btn');
    const gchatScrollBottomBtn = document.getElementById('gchat-scroll-bottom-btn');

    window.gchatScrollToTop = function() {
      gchatMsgsDiv.scrollTo({ top: 0, behavior: 'smooth' });
    };

    window.gchatScrollToBottom = function() {
      gchatMsgsDiv.scrollTo({ top: gchatMsgsDiv.scrollHeight, behavior: 'smooth' });
    };

    function updateGchatScrollButtons() {
      if (!globalChatMode) return;
      const scrollTop = gchatMsgsDiv.scrollTop;
      const scrollHeight = gchatMsgsDiv.scrollHeight;
      const clientHeight = gchatMsgsDiv.clientHeight;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;

      if (scrollTop > SCROLL_THRESHOLD) {
        gchatScrollTopBtn.classList.add('visible');
      } else {
        gchatScrollTopBtn.classList.remove('visible');
      }

      if (distanceFromBottom > SCROLL_THRESHOLD) {
        gchatScrollBottomBtn.classList.add('visible');
      } else {
        gchatScrollBottomBtn.classList.remove('visible');
      }
    }

    gchatMsgsDiv.addEventListener('scroll', updateGchatScrollButtons);

    function handleKeydown(e) {
      // Tab: Accept the suggestion and place cursor at end
      if (e.key === 'Tab' && getCurrentSuggestion() && !input.value.trim()) {
        e.preventDefault();
        acceptSuggestion();
        return;
      }

      // Enter: Send message (or suggestion if no user input)
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        // If there's a suggestion and no user input, send the suggestion
        if (getCurrentSuggestion() && !input.value.trim()) {
          input.value = getCurrentSuggestion();
          clearSuggestion();
        }
        handleSendClick();
        return;
      }

      // Escape: Clear the suggestion
      if (e.key === 'Escape' && getCurrentSuggestion()) {
        e.preventDefault();
        clearSuggestion();
        return;
      }
    }

    function autoResizeTextarea() {
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 150) + 'px';
    }

    function handleInput(e) {
      // When user types, clear the suggestion
      if (getCurrentSuggestion() && input.value.trim()) {
        clearSuggestion();
      }
      autoResizeTextarea();
    }

    function setSuggestion(text) {
      if (!text) {
        clearSuggestion();
        return;
      }
      setCurrentSuggestion(text);
      ghostSuggestion.innerHTML = escapeHtml(text) + '<span class="tab-hint">Tab to accept</span>';
      ghostSuggestion.style.display = 'block';
      input.classList.add('has-suggestion');
    }

    function clearSuggestion() {
      setCurrentSuggestion(null);
      ghostSuggestion.innerHTML = '';
      ghostSuggestion.style.display = 'none';
      input.classList.remove('has-suggestion');
    }

    function acceptSuggestion() {
      if (!getCurrentSuggestion()) return;
      input.value = getCurrentSuggestion();
      clearSuggestion();
      autoResizeTextarea();
      // Place cursor at the end
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
    }

    function triggerAttach() {
      fileInput.click();
    }

    async function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      for (const file of files) {
        const ext = file.name.split('.').pop()?.toLowerCase() || '';

        // Validate extension
        if (!ALLOWED_EXTENSIONS.has(ext)) {
          addMessage('system', `Unsupported file type: ${file.name}`);
          continue;
        }

        // Validate size
        if (file.size > MAX_FILE_SIZE) {
          addMessage('system', `File too large (max 10MB): ${file.name}`);
          continue;
        }

        try {
          const attachment = await readFile(file, ext);
          const currentAttachments = getPendingAttachments();
          currentAttachments.push(attachment);
          setPendingAttachments(currentAttachments);
        } catch (err) {
          addMessage('system', `Failed to read file: ${file.name}`);
        }
      }

      // Reset file input and update UI
      fileInput.value = '';
      renderAttachmentPreviews();
      input.focus();
    }

    async function readFile(file, ext) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          const attachment = {
            name: file.name,
            type: file.type,
            size: file.size,
            ext: ext,
            isImage: IMAGE_EXTENSIONS.has(ext),
          };

          if (attachment.isImage || BINARY_EXTENSIONS.has(ext) || EXTRACTABLE_EXTENSIONS.has(ext)) {
            // Store as data URL for images and binary/extractable documents
            attachment.dataUrl = e.target.result;
            attachment.content = null;
          } else {
            // Store as text for text files
            attachment.dataUrl = null;
            attachment.content = e.target.result;
          }

          resolve(attachment);
        };

        reader.onerror = () => reject(reader.error);

        if (IMAGE_EXTENSIONS.has(ext) || BINARY_EXTENSIONS.has(ext) || EXTRACTABLE_EXTENSIONS.has(ext)) {
          reader.readAsDataURL(file);
        } else {
          reader.readAsText(file);
        }
      });
    }

    function renderAttachmentPreviews() {
      // Remove existing container
      const existing = document.querySelector('.attachments-container');
      if (existing) existing.remove();

      const attachments = getPendingAttachments();
      if (attachments.length === 0) return;

      // Create container
      const container = document.createElement('div');
      container.className = 'attachments-container';

      attachments.forEach((att, index) => {
        const preview = document.createElement('div');
        preview.className = 'attachment-preview';

        if (att.isImage && att.dataUrl) {
          const img = document.createElement('img');
          img.src = att.dataUrl;
          img.alt = att.name;
          preview.innerHTML = `
            <div class="attachment-info">
              <div class="attachment-name">${escapeHtml(att.name)}</div>
              <div class="attachment-size">${formatFileSize(att.size)}</div>
            </div>
            <button class="attachment-remove" onclick="playNormalClick(); removeAttachment(${index})">Ã—</button>
          `;
          preview.insertBefore(img, preview.firstChild);
        } else {
          preview.innerHTML = `
            <div class="attachment-icon">${att.ext}</div>
            <div class="attachment-info">
              <div class="attachment-name">${escapeHtml(att.name)}</div>
              <div class="attachment-size">${formatFileSize(att.size)}</div>
            </div>
            <button class="attachment-remove" onclick="playNormalClick(); removeAttachment(${index})">Ã—</button>
          `;
        }

        container.appendChild(preview);
      });

      // Insert before input area
      const inputArea = document.getElementById('input-area');
      inputArea.parentNode.insertBefore(container, inputArea);
    }

    function removeAttachment(index) {
      const attachments = getPendingAttachments();
      attachments.splice(index, 1);
      setPendingAttachments(attachments);
      renderAttachmentPreviews();
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function clearAttachments() {
      setPendingAttachments([]);
      renderAttachmentPreviews();
    }

    // Drag and Drop handling
    const dragOverlay = document.getElementById('drag-overlay');
    let dragCounter = 0; // Track nested drag events

    function showDragOverlay() {
      dragOverlay.classList.add('active');
    }

    function hideDragOverlay() {
      dragOverlay.classList.remove('active');
    }

    // Prevent default drag behaviors on the whole document
    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;

      // Only show overlay if dragging files (types is DOMStringList, use contains not includes)
      if (e.dataTransfer?.types?.contains('Files')) {
        showDragOverlay();
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;

      // Hide overlay when drag leaves the window entirely
      if (dragCounter === 0) {
        hideDragOverlay();
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });

    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      hideDragOverlay();

      const files = Array.from(e.dataTransfer?.files || []);
      if (files.length === 0) return;

      for (const file of files) {
        const ext = file.name.split('.').pop()?.toLowerCase() || '';

        // Validate extension
        if (!ALLOWED_EXTENSIONS.has(ext)) {
          addMessage('system', `Unsupported file type: ${file.name}`);
          continue;
        }

        // Validate size
        if (file.size > MAX_FILE_SIZE) {
          addMessage('system', `File too large (max 10MB): ${file.name}`);
          continue;
        }

        try {
          const attachment = await readFile(file, ext);
          const currentAttachments = getPendingAttachments();
          currentAttachments.push(attachment);
          setPendingAttachments(currentAttachments);
        } catch (err) {
          addMessage('system', `Failed to read file: ${file.name}`);
        }
      }

      renderAttachmentPreviews();
      input.focus();
    });

    // Auto-resize textarea
    input.addEventListener('input', () => {
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 150) + 'px';
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Cmd/Ctrl + K to clear
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        clearChat();
      }
      // Cmd/Ctrl + , to open settings
      if ((e.metaKey || e.ctrlKey) && e.key === ',') {
        e.preventDefault();
        openSettings();
      }
    });

    async function openSettings(tab) {
      try {
        await window.pocketAgent.openSettings(tab);
      } catch (err) {
        console.error('Failed to open settings:', err);
      }
    }

    async function checkForUpdates() {
      try {
        const result = await window.pocketAgent.checkForUpdates();
        const updateBadge = document.getElementById('update-badge');
        if (result.status === 'available' && result.info?.version) {
          updateBadge.textContent = `v${result.info.version}`;
          updateBadge.style.display = 'inline-block';
        } else {
          updateBadge.style.display = 'none';
        }
      } catch (err) {
        // Silently fail - update check is not critical
        console.debug('Update check failed:', err);
      }
    }

    async function openFactsGraph() {
      try {
        await window.pocketAgent.openFactsGraph();
      } catch (err) {
        console.error('Failed to open facts graph:', err);
      }
    }

    async function openCustomize() {
      try {
        await window.pocketAgent.openCustomize();
      } catch (err) {
        console.error('Failed to open customize:', err);
      }
    }

    // Hamburger menu functions
    function toggleMenu() {
      const btn = document.getElementById('hamburger-btn');
      const dropdown = document.getElementById('menu-dropdown');
      const isOpen = dropdown.classList.contains('open');

      if (isOpen) {
        closeMenu();
      } else {
        btn.classList.add('active');
        dropdown.classList.add('open');
      }
    }

    function closeMenu() {
      const btn = document.getElementById('hamburger-btn');
      const dropdown = document.getElementById('menu-dropdown');
      btn.classList.remove('active');
      dropdown.classList.remove('open');
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      const menu = document.querySelector('.hamburger-menu');
      if (menu && !menu.contains(e.target)) {
        closeMenu();
      }
    });

    // Close menu on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeMenu();
        closeDailyTasks();
      }
    });

    async function openRoutines() {
      try {
        await window.pocketAgent.openRoutines();
      } catch (err) {
        console.error('Failed to open routines:', err);
      }
    }

    async function openDocs() {
      try {
        await window.pocketAgent.openExternal('https://pocketagent-web.vercel.app/docs');
      } catch (err) {
        console.error('Failed to open docs:', err);
      }
    }

    function openAbout() {
      document.getElementById('about-modal').classList.add('show');
    }

    function closeAbout() {
      document.getElementById('about-modal').classList.remove('show');
    }
  </script>
</body>
</html>
